stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [*] (#idnr) mode="idnr-hunting" {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*] (#idnr = $idnr) mode="idnr-hunting";
  }
}

tpl [Simple-Term] (#idnr) mode="idnr-hunting" {
  if [@idnr = $idnr] {
    <it-Term {
      @induced = "induced";
    }
  } else {
    apply [.];
  }
}

tpl [Text-Proper/Item[@kind = "Reservation"]] {
  $type = `*[position() = last()]`;
  $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"])`;
  for-each [Variable] {
    <Item {
      for-each [@*] { copy-of `.`; }
      @kind = "Reservation";
      @toplevel-binder-number = `position() + $num-previous-toplevel`;
      if [@idnr] {
        @idnr = `@idnr`;
      } else {
        die (#message = "We found a variable that lacks an idnr attribute; unable to proceed.");
      }
      apply [.];
      apply [$type];
    }
  }
}

tpl [Text-Proper/Item[@kind = "Private-Predicate-Definition" or @kind = "Private-Functor-Definition" or @kind = "Constant-Definition"]] {
  if [Variable[2]] {
    die (#message = "We assume that private predicate/functor definitions bind at most one variable, but we found one that binds at least two!");
  }
  <Item {
    for-each [@*] { copy-of `.`; }
    @toplevel-binder-number = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"]) + 1`;
    @idnr = `Variable[1]/@idnr`;
    apply [*];
  }
}

// Given a nodeset of propositions and a nodeset of
// explicitly/implicitly qualified segments, form the existential
// generalization of the conjunction of $propositions over those
// segments
tpl existentially-generalize (#variables, #starting-after, #idnr-to-it-term, #type, #propositions) {
  $starting-index = `$starting-after + 1`;
  $variable = `$variables[$starting-index]`;
  if [$variable] {
    <Existential-Quantifier-Formula {
      <Explicitly-Qualified-Segment {
        apply [$variable];
        apply [$type];
      }
      existentially-generalize (#variables = $variables,
                                #starting-after = $starting-index,
                                #idnr-to-it-term = $idnr-to-it-term,
                                #type = $type,
                                #propositions = $propositions);
    }
  } else {
    if [$propositions] {
      $proposition = `$propositions[1]`;
      $formula = `$proposition/*[position() = last()]`; // skip the label, if there is one
      if [$propositions[2]] {
        <Conjunctive-Formula {
          apply [$formula] (#idnr = $idnr-to-it-term) mode="idnr-hunting";
          existentially-generalize (#variables = $variables,
                                    #type = $type,
                                    #starting-after = $starting-after,
                                    #idnr-to-it-term = $idnr-to-it-term,
                                    #propositions = `$propositions[position() > 1]`);
        }
      } else {
        apply [$formula] (#idnr = $idnr-to-it-term) mode="idnr-hunting";
      }
    }
  }
}

tpl conjoin-propositions (#propositions) {
  if [$propositions] {
    $proposition = `$propositions[1]`;
    $formula = `$proposition/*[position() = last()]`; // skip the label, if there is one
    if [$propositions[2]] {
      <Conjunctive-Formula {
        apply [$formula];
        conjoin-propositions (#propositions = `$propositions[position() > 1]`);
      }
    } else {
      apply [$formula];
    }
  }
}

key "spelling" [//*] `@spelling`;

tpl new-spelling-based-on (#base, #try) {
  $candidate = `concat ($base, $try)`;
  if [key ("spelling", $candidate)] {
    new-spelling-based-on (#base = $base,
                           #try = `$try + 1`);
  } else {
    $candidate;
  }
}

tpl new-dummy-mode-name {
  new-spelling-based-on (#base = "DummyMode", #try = "1");
}

tpl [Text-Proper/Item[@kind = "Choice-Statement"]] {

  if [not (Explicitly-Qualified-Segment | Implicitly-Qualified-Segment)] {
    die (#message = "We expect a Choice-Statement to have either an Explicitly-Qualified-Segment or an Implicitly-Qualified-Segment child, but this choice statement lacks both");
  }

  // treat first the case of one variable in a consider
  if [not(Explicitly-Qualified-Segment)] {
    die (#message = "We don't yet know how to deal with a choice statement that lacks an explicit type for the variables it introduces.");
  }
  if [Explicitly-Qualified-Segment[2]] {
    die (#message = "We don't know yet how to deal with toplevel choice statements that involve binding variables of different types");
  }

  $context = `.`;
  $justification = `$context/*[position() = last()]`;
  $type = `Explicitly-Qualified-Segment/*[position() = last()]`;
  $variables = `Explicitly-Qualified-Segment/Variable`;

  for-each [$variables] {

    if [not(@idnr)] {
      die (#message = "We encountered a Variable element that lacks an idnr attribute!");
    }
    if [not(@spelling)] {
      die (#message = "We encountered a Variable element that lacks a spelling attribute!");
    }

    $variable-idnr = `@idnr`;
    $variable-spelling = `@spelling`;
    $position = `position ()`;

    // dummy mode
    $mode-name = new-spelling-based-on (#base = "DummyMode", #try = $position);
    <Item {
      @kind = "Definition-Item";
      @promoted = "choice-statement-mode";
      @spelling = $mode-name;
      <Block {
        @kind = "Definitional-Block";
        <Item {
          @kind = "Mode-Definition";
          <Mode-Pattern {
            @spelling = $mode-name;
            <Loci;
          }
          <Standard-Mode {
            @kind = "Simple-Definiens";
            if [$type] {
              <Type-Specification {
                apply [$type];
              }
            }
            <Definiens {
              <Formula-Expression;
              existentially-generalize (#variables = $variables,
                                        #starting-after = $position,
                                        #idnr-to-it-term = $variable-idnr,
                                        #type = $type,
                                        #propositions = `$context/Proposition`);
            }
          }
        }
        <Item {
          @kind = "Correctness-Condition";
          <Existence;
          apply [$justification];
        }
      }
    }

    // dummy functor symbol
    <Item {
      @kind = "Definition-Item";
      @promoted = "choice-statement-functor";
      @spelling = $variable-spelling;
      <Block {
        @kind = "Definitional-Block";
        <Item {
          @kind = "Functor-Definition";
          <Operation-Functor-Pattern {
            @spelling = $variable-spelling;
            <Loci;
            <Loci;
          }
          if [$type] {
            <Type-Specification {
              apply [$type];
            }
          }
          <Equals;
          <Definiens {
            @kind = "Simple-Definiens";
            <Global-Choice-Term {
              <Standard-Type {
                @spelling = $mode-name;
              }
            }
          }
        }
        <Item {
          @kind = "Correctness-Condition";
          <Coherence;
          <Straightforward-Justification;
        }
      }
    }
  }

  // conjunction of the propositions
  <Item {
    @kind = "Theorem-Item";
    @promoted = "choice-statement-conditions";
    <Proposition {
      conjoin-propositions (#propositions = `Proposition`);
    }
    <Straightforward-Justification;
  }

  if [Proposition[2]] {
    for-each [Proposition] {
      <Item {
        @kind = "Regular-Statement";
        @promoted = "choice-statement-condition";
        <Compact-Statement;
        apply [.];
        <Straightforward-Justification;
      }
    }
  }

}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement"]] {
  $type = `*[position() = last()]`;
  $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"])`;
  for-each [Variable] {
    <Item {
      for-each [@*] { copy-of `.`; }
      @kind = "Type-Changing-Statement";
      @toplevel-binder-number = `position() + $num-previous-toplevel`;
      apply [.];
      apply [$type];
    }
  }
}

tpl [Text-Proper/Item[@kind = "Regular-Statement"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    if [Proposition/Label] {
      @idnr = `Proposition/Label[1]/@idnr`;
    } else {
      @idnr = "";
    }
    if [Diffuse-Statement] {
      $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"])`;
      @toplevel-binder-number = `$num-previous-toplevel + 1`;
    }
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind = "Constant-Definition"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    @idnr = `Variable[1]/@idnr`;
    $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"])`;
    @toplevel-binder-number = `$num-previous-toplevel + 1`;
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    @idnr = `Equality/Variable[1]/@idnr`;
    $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement)] | preceding::Item[@kind = "Loci-Declaration"])`;
    @toplevel-binder-number = `$num-previous-toplevel + 1`;
    apply [*];
  }
}

tpl [Item[@kind = "Loci-Declaration"]] {
  $loci = `.`;
  for-each [Implicitly-Qualified-Segment | Explicitly-Qualified-Segment] {
    $segment_element_name = `local-name (.)`;
    for-each [Variable] {
      <Item {
        for-each [$loci/@*] { copy-of `.`; }
        $num_preceding = `count (preceding::Item[@kind = "Loci-Declaration"] | preceding::Item[@kind = "Reservation"] | preceding::Item[@kind = "Private-Functor-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Choice-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Constant-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Type-Changing-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Private-Predicate-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Regular-Statement" and child::Diffuse-Statement and parent::Text-Proper])`;
        @toplevel-binder-number = `$num_preceding + 1`;
        @idnr = `@idnr`;
        <$segment_element_name {
          apply [.]; // variable
          if [$segment_element_name = "Explicitly-Qualified-Segment"] {
            apply [../*[position() = last()]]; // the type of the variable
          }
        }
      }
    }
  }
}

tpl [Item[@kind="Definition-Item"]] {
  $context = `.`;
  apply [Block] (#context = $context);
}

tpl [Block[@kind="Definitional-Block"]] (#context) {
  apply [Item[@kind = "Attribute-Definition" or @kind = "Functor-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition" or @kind = "Structure-Definition"]](#definitions = `Item[@kind = "Private-Predicate-Definition" or @kind="Private-Functor-Definition"]`, #context = $context);
}

tpl [Block[@kind = "Registration-Block"]] {
  apply [Item[@kind = "Cluster"]];
}

tpl [Block[@kind = "Notation-Block"]] {
  apply [Item[@kind = "Pred-Antonym" or @kind = "Pred-Synonym" or @kind = "Attr-Antonym" or @kind = "Attr-Synonym" or @kind = "Func-Synonym" or @kind = "Func-Antonym" or @kind = "Mode-Synonym" or @kind = "Mode-Antonym"]];
}

tpl [Item[@kind = "Cluster"]] {
  <Item {
    @kind = "Definition-Item";
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    <Block {
      @kind = "Registration-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = "Cluster";
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl correctness-conditions (#candidates, #definitions, #stop) {
  if [not($stop = "1")] {
    if [$candidates] {
      $candidate = `$candidates[1]`;
      for-each [$candidate] {
        $candidate_name = `local-name(.)`;
        $candidate_kind = `$candidate/@kind`;
        if [$candidate_name = "Item" and ($candidate_kind = "Correctness-Condition" or $candidate_kind = "Property" or $candidate_kind = "Correctness")] {
          apply [$candidate](#definitions = $definitions);
          correctness-conditions (#candidates = `$candidates[position() > 1]`,
                                  #definitions = $definitions);
        } else {
          correctness-conditions (#stop = "1");
        }
      }
    }
  }
}

tpl [Item[@kind = "Correctness-Condition" or @kind = "Property" or @kind = "Correctness"]](#definitions) {
  <Item {
    @kind = `@kind`;
    apply [*](#definitions = $definitions);
  }
}

tpl [Item[@kind = "Theorem-Item"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Block[@kind = "Proof"]](#definitions) {
  $context = `.`;
  <Block {
    @kind = "Proof";
    if [$definitions] {
      for-each [$definitions] {
        if [Variable] {
          $idnr = `Variable[1]/@idnr`;
          if [$context//Private-Predicate-Formula[@idnr = $idnr] or $context//Private-Functor-Term[@idnr = $idnr]] {
            copy-of `.`;
          }
        } else {
          die (#message = "While determining whether to possibly include some local definitions into a proof, we encountered a local definition that lacks a Variable child");
        }
      }
    }
    apply [*];
  }
}

tpl [Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition" or @kind = "Structure-Definition"]](#definitions, #context) {
  <Item {
    for-each [$context/@*] { copy-of `.`; }
    @kind = "Definition-Item";
    <Block {
      @kind = "Definitional-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration" or @kind = "Assumption" or @kind = "Existential-Assumption"]] {
        apply [.];
      }
      <Item {
        @kind = `@kind`;
        if [@line] { @line = `@line`; }
        if [@col] { @col = `@col`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`, #definitions = $definitions);
    }
  }
}

tpl [Item[@kind = "Pred-Synonym" or @kind = "Pred-Antonym" or @kind = "Attr-Synonym" or @kind = "Attr-Antonym" or @kind = "Func-Synonym" or @kind = "Func-Antonym" or @kind = "Mode-Synonym" or @kind = "Mode-Antonym"]] {
  <Item {
    @kind = "Definition-Item";
    <Block {
      @kind = "Notation-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = `@kind`;
        if [@line] { @line = `@line`; }
        if [@col] { @col = `@col`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl split-explicitly-qualified-segment (#variables, #type) {
  if [$variables] {
    $variable = `$variables[1]`;
    <Explicitly-Qualified-Segment {
      apply [$variable];
      apply [$type];

    }
    split-explicitly-qualified-segment (#variables = `$variables[position() > 1]`,
                                        #type = $type);
  }
}

tpl [Explicitly-Qualified-Segment] {
  split-explicitly-qualified-segment (#variables = `Variable`,
                                      #type = `*[position() = last()]`);
}

// don't break up explicitly qualified segments inside universal formulas...yet
tpl [Universal-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}

tpl [Existential-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}