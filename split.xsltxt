stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    if [@spelling] { @spelling = `@spelling`; }
    if [@idnr] { @idnr = `@idnr`; }
    if [@nr] { @nr = `@nr`; }
    if [@number] { @"number" = `@number`; }
    if [@articleid] { @articleid = `@articleid`; }
    if [@kind] { @kind = `@kind`; }
    apply [*];
  }
}

tpl split-reservation (#variables, #type) {
  if [$variables] {
    $variable = `$variables[1]`;
    <Item {
      @kind = "Reservation";
      @idnr = $variable/@idnr;
      apply [$variable];
      apply [$type];

    }
    split-reservation (#variables = `$variables[position() > 1]`,
                       #type = $type);
  }
}

tpl [Item[@kind="Reservation"]] {
  $type = `*[position() = last()]`;
  for-each [Variable] {
    <Item {
      @kind = "Reservation";
      @idnr = `@idnr`;
      @reservation-number = `position() + count(preceding::Item[@kind = "Reservation"]/Variable)`;
      apply [.];
      apply [$type];
    }
  }
}

tpl [Item[@kind = "Loci-Declaration"]] {
  <Item {
    @kind = "Loci-Declaration";
    @line = `@line`;
    @col = `@col`;
    $num_preceding = `count (preceding::Item[@kind = "Loci-Declaration"] | ancestor::Item[@kind = "Loci-Declaration"])`;
    @loci-number = `$num_preceding + 1`;
    for-each [Implicitly-Qualified-Segment/Variable[1] | Explicitly-Qualified-Segment/Variable[1]] {
      @idnr = `@idnr`;
    }
    apply [*];
  }
}

tpl [Item[@kind="Definition-Item"]] {
  apply [Block];
}

tpl [Block[@kind="Definitional-Block"]] {
  apply [Item[@kind = "Attribute-Definition" or @kind = "Functor-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition"]](#definitions = `Item[@kind = "Private-Predicate-Definition"]`);
}

tpl [Block[@kind = "Registration-Block"]] {
  apply [Item[@kind = "Cluster"]];
}

tpl [Block[@kind = "Notation-Block"]] {
  apply [Item[@kind = "Pred-Antonym" or @kind = "Pred-Synonym"]];
}

tpl [Item[@kind = "Cluster"]] {
  $context = `.`;
  $def_line = `$context/@line`;
  $def_col = `$context/@col`;
  <Item {
    @kind = "Definition-Item";
    <Block {
      @kind = "Registration-Block";
      for-each [.//Simple-Term] {
        $idnr = `@idnr`;
        $spelling = `@spelling`;
        $locus_line = `@line`;
        $locus_col = `@col`;
        for-each [$context] { // now go hunting for the type of this Locus
          if [preceding-sibling::Item[@kind = "Loci-Declaration"]//Variable[@spelling = $spelling]] {
            for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]//Variable[@spelling = $spelling][1]] {
              <Item {
                @kind = "Loci-Declaration";
                <Explicitly-Qualified-Segment {
                  <Variable {
                    @idnr = $idnr;
                    @spelling = $spelling;
                  }
                  if [local-name(..) = "Explicitly-Qualified-Segment"] {
                    apply [../*[position() = last()]];
                  } else {
                    if [preceding::Item[@kind = "Reservation"]/Variable[@idnr = $idnr]] {
                      apply [preceding::Item[@kind = "Reservation"]/Variable[@idnr = $idnr]/../*[position() = last()]]; // WOW
                    } else {
                      $message = `concat ("While looking for a suitable type for the variable ", $spelling, " at line ", $locus_line, " and column ", $locus_col, ", we found that it is not bound by a previous Loci-Declaration element that explicitly assigns a type to this variable, nor were we able to find an earlier reservation that assigns a type to this varialbe.")`;
                      die (#message = $message);
                    }
                  }
                }
              }
            }
          } else {
            $message = `concat ("While processing a cluster at line ", $def_line, " and column ", $def_col, ", we encountered a pattern in which ", $spelling, " occurs, but we could not find a Loci-Declaration item preceding this locus that binds ", $spelling)`;
            die (#message = $message);
          }
        }
      }
      copy-of `.`;
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl correctness-conditions (#candidates, #definitions, #stop) {
  if [not($stop = "1")] {
    if [$candidates] {
      $candidate = `$candidates[1]`;
      for-each [$candidate] {
        $candidate_name = `local-name(.)`;
        $candidate_kind = `$candidate/@kind`;
        if [$candidate_name = "Item" and ($candidate_kind = "Correctness-Condition" or $candidate_kind = "Property" or $candidate_kind = "Correctness")] {
          apply [$candidate](#definitions = $definitions);
          correctness-conditions (#candidates = `$candidates[position() > 1]`,
                                  #definitions = $definitions);
        } else {
          correctness-conditions (#stop = "1");
        }
      }
    }
  }
}

tpl [Item[@kind = "Correctness-Condition" or @kind = "Property" or @kind = "Correctness"]](#definitions) {
  <Item {
    @kind = `@kind`;
    apply [*](#definitions = $definitions);
  }
}

tpl [Block[@kind = "Proof"]](#definitions) {
  $context = `.`;
  <Block {
    @kind = "Proof";
    if [$definitions] {
      for-each [$definitions] {
        if [Variable] {
          $idnr = `Variable[1]/@idnr`;
          if [$context//Private-Predicate-Formula[@idnr = $idnr]] {
            apply [*];
          }
        } else {
          die (#message = "While determining whether to possibly include some local definitions into a proof, we encountered a local definition that lacks a Variable child");
        }
      }
    }
    apply [*];
  }
}

tpl [Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition"]](#definitions) {
  <Item {
    @kind = "Definition-Item";
    <Block {
      @kind = "Definitional-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = `@kind`;
        if [@line] { @line = `@line`; }
        if [@col] { @col = `@col`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`, #definitions = $definitions);
    }
  }
}

tpl [Item[@kind = "Pred-Synonym" or @kind = "Pred-Antonym"]] {
  <Item {
    @kind = "Definition-Item";
    <Block {
      @kind = "Notation-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = `@kind`;
        if [@line] { @line = `@line`; }
        if [@col] { @col = `@col`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl split-explicitly-qualified-segment (#variables, #type) {
  if [$variables] {
    $variable = `$variables[1]`;
    <Explicitly-Qualified-Segment {
      apply [$variable];
      apply [$type];

    }
    split-explicitly-qualified-segment (#variables = `$variables[position() > 1]`,
                                        #type = $type);
  }
}

tpl [Explicitly-Qualified-Segment] {
  split-explicitly-qualified-segment (#variables = `Variable`,
                                      #type = `*[position() = last()]`);
}

// don't break up explicitly qualified segments inside universal formulas...yet
tpl [Universal-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}

tpl [Existential-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}