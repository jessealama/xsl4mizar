stylesheet "1.0";

output method="xml" encoding="utf-8";
output doctype-public="-//W3C//DTD XHTML 1.1//EN";
output doctype-system="http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd";
output omit-xml-declaration="no";

include utils/die.xsl;

tpl list (#separ, #elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { copy-of $separ; } }
}

tpl [/] {
  <html {
    @"xmlns" = "http://www.w3.org/1999/xhtml";
    @xml:lang="en";
    <head {
      <title {
        "hey there";
      }
      <link {
        @rel = "stylesheet";
        @type = "text/css";
        @href = "tstp.css";
      }
    }
    <body {
      <table {
        <thead {
          <tr {
            <th { "Name"; }
            <th { "Status"; }
            <th { "Formula"; }
            <th { "Source"; }
            <th { "Info"; }
          }
        }
        <tbody {
          apply [*];
        }
      }
    }
  }
}

tpl [comment] {
  <tr {
    <td {
      @colspan = "5";
      @class = "comment";
      `.`;
    }
  }
}

tpl [formula[not(@name)]] {
  die (#message = "We require that a formula element have a name attribute!");
}

tpl [formula[not(@status)]] {
  die (#message = "We require that a formula element have a status attribute!");
}

tpl [defined-predicate[@name = "true"]] {
  "&#8868;";
}

tpl [defined-predicate[not(@name = "true")]] {
  $message = `concat ("We don't know how to deal with a defined predicate whose name is not 'true' (the name is '", $name, "'")`;
  die (#message = $message);
}

tpl [formula[@name]] {
  <tr {
    <td {
      @"id" = `@name`;
      @class = "formula-name";
      `@name`;
     }
     <td {
       @class = "status";
       `@status`;
     }
     <td {
      @class = "formula";
      apply [*[1]];
    }
    <td {
      @class = "source";
      apply [source];
    }
    <td {
      @class = "useful-info";
      apply [useful-info];
    }
  }
}

// variables

tpl [variable[not(@name)]] {
  die (#message = "We require that variables have a name attribute!");
}

tpl [variable[@name]] {
  <span {
    @class = "variable";
    `@name`;
  }
}

// formula shapes

tpl [predicate[not(@name)]] {
  die (#message = "We require that a variable have a name attribute!");
}

tpl [predicate[@name = "=" and not(child::*[2])]] {
  die (#message = "We require that an equality predicate element have at least two children!");
}

tpl [predicate[@name = "=" and child::*[3]]] {
  die (#message = "We require that an equality predicate element have fewer than three children!");
}

tpl [predicate[@name = "="]] {
  "(";
  apply [*[1]];
  <span {
    @class = "predicate";
    " = ";
  }
  apply [*[2]];
  ")";
}

tpl [predicate[@name and not(@name = "=")]] {
  <span {
    @class = "predicate";
    `@name`;
  }
  "(";
  list (#separ = ", ", #elems = `*`);
  ")";
}

tpl [function[not(@name)]] {
  die (#message = "We require that a function have a name attribute!");
}

tpl [function[@name]] {
  <span {
    @class = "function";
    `@name`;
  }
  "(";
  list (#separ = ", ", #elems = `*`);
  ")";
}

tpl [*[not(child::*[2])]] mode="binary-connective" {
  $shape = `local-name (.)`;
  $message = `concat ("Elements of type '", $shape, "' are intended to represent binary connectives, but we have found such an element that lacks two children")`;
  die (#message = $message);
}

tpl [*[child::*[3]]] mode="binary-connective" {
  $shape = `local-name (.)`;
  $message = `concat ("Elements of type '", $shape, "' are intended to represent binary connectives, but we have found such an element that has more than two children")`;
  die (#message = $message);
}

tpl [*] (#connective) mode="binary-connective" {
  "("; apply [*[1]]; `$connective`; apply [*[2]]; ")";
}

tpl [implication] {
  apply [.] (#connective = "&#8594;") mode="binary-connective";
}

tpl [equivalence] {
  apply [.] (#connective = "&#8596;") mode="binary-connective";
}

// unary connectives

tpl [*[not(child::*)]] mode="unary-connective" {
  $shape = `local-name (.)`;
  $message = `concat ("Elements of type '", $shape, "' are intended to represent unary connectives, but we have found such an element that lacks a child!")`;
  die (#message = $message);
}

tpl [*[child::*[3]]] mode="unary-connective" {
  $shape = `local-name (.)`;
  $message = `concat ("Elements of type '", $shape, "' are intended to represent unary connectives, but we have found such an element that has more than one child")`;
  die (#message = $message);
}

tpl [*] (#connective) mode="unary-connective" {
  copy-of $connective; apply [*[1]];
}

tpl [negation] {
  apply [.] (#connective = "&#172;") mode="unary-connective";
}

// quantifiers

tpl [quantifier[not(@type)]] {
  die (#message = "Quantifiers must have a type attribute, but we found one that lacks this attribute!");
}

tpl [quantifier[@type and not(@type = "universal" or @type = "existential")]] {
  die (#message = "We assume that quantifiers are either universal or existential!");
}

tpl [quantifer[not(child::variable)]] {
  die (#message = "We require that quantifiers have at least one variable child!");
}

tpl [quantifier[not(child::*[2])]] {
  die (#message = "We require that quantifiers have at least two child elements!");
}

tpl [quantifier[@type = "universal" or @type = "existential"]] {
  $type = `@type`;
  if [$type = "universal"] {
    "&#8704;";
  } else {
    "&#8707;";
  }
  list (#elems = `variable`,
        #separ = ", ");
  "["; apply [*[position() = last()]]; "]";
}

// sources

tpl [source] {
  <div {
    @class = "source";
    apply [*];
  }
}

tpl [non-logical-data[not(@name)]] {
  "["; list (#elems = `*`, #separ = ","); "]";
}

tpl [non-logical-data[@name and not(@name = "assumptions")]] {
  "["; `@name`; list (#elems = `*`, #separ = ","); "]";
}

tpl [non-logical-data[@name = "assumptions"]] {
  "[";
  for-each [non-logical-data/non-logical-data] {
    apply [.] mode="link";
    if [not(position() = last())] {
      ",";
    }
  }
  "]";
}

tpl [non-logical-data[not(@name)]] mode="link" {
  die (#message = "We cannot link a non-logical-data element that lacks a name attribute!");
}

tpl [non-logical-data[@name]] mode="link" {
  $n = `@name`;
  <a {
    @href = `concat ("#", $n)`;
    `$n`;
  }
}

tpl [useful-info] {
  <div {
    @class = "useful-info";
    apply [*];
  }
}

tpl [number[not(@name)]] {
  die (#message = "We require that numbe elements have a name attribute!");
}

tpl [number[@name]] {
  `@name`;
}