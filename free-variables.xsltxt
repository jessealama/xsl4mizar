stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [*] {
  $element = `local-name ()`;
  $free = free-variables (#element = `.`);
  $unique-free = remove-duplicate-tokens (#string = $free);
  <$element {
    for-each [@*] {
      copy-of `.`;
    }
    @free-variables = $unique-free;
    apply [*];
  }
}

tpl [Text-Proper] mode="free-variables" {
  "";
}

// Computing free variables


// Given a string that looks like
//
// ,56,13,193,13,13,
//
// remove any duplicate "tokens".  (In this example, the token "13"
// appears three times.)
//
// It is permitted for the string to be empty.
tpl remove-duplicate-tokens (#string) {
  choose {
    when [$string = ""] { ""; }
    when [starts-with ($string, ",")] {
      $after-first-comma = `substring-after ($string, ",")`;
      choose {
        when [contains ($after-first-comma, ",")] {
          $between-first-and-second-comma = `substring-before ($after-first-comma, ",")`;
          $initially-commaless-tail = `substring-after ($after-first-comma, ",")`;
          $token = `concat (",", $between-first-and-second-comma, ",")`;
          $tail = `substring-after ($initially-commaless-tail, ",")`;
          choose {
            when [$initially-commaless-tail = ""] { $token; }
            when [starts-with ($initially-commaless-tail, ",")] {
              $message = `concat ("We expected to find that the tail, '", $initially-commaless-tail, "' of our token string, does not begin with a comma, but somehow it does")`;
              die (#message = $message);
            }
            when [contains ($tail, $token)] { remove-duplicate-tokens (#string = $tail); }
            otherwise {
              $duplicate-free-tail = remove-duplicate-tokens (#string = $tail);
              choose {
                when [$duplicate-free-tail = ""] { $token; }
                when [starts-with ($duplicate-free-tail, ",")] {
                  $duplicate-free-tail-after-first-comma = `substring-after ($duplicate-free-tail, ",")`;
                  `concat ($token, $duplicate-free-tail-after-first-comma)`;
                }
                otherwise {
                  $message = `concat ("When removing duplicates from the string '", $string, "', we removed duplicates from its tail, '", $tail, "'; somehow we obtained '", $duplicate-free-tail, "', which doesn't begin with a comma.  This is not the expected format for a token string, so we can't proceed.")`;
                  die (#message = $message);
                }
              }
            }
          }
        }
        otherwise {
          $message = `concat ("Cannot remove duplicate elements from a token string that doesn't start with a comma and contain at least one more comma!  (We were given '", $string, "'.")`;
          die (#message = $message);
        }
      }
    }
    otherwise {
      $message = `concat ("Cannot remove duplicate elements from a token string that doesn't start with a comma!  (We were given '", $string, "'.")`;
      die (#message = $message);
    }
  }
}

tpl free-variables (#element) {
  apply [$element] mode="free-variables";
}

tpl append-free-variables (#elements) {
  if [$elements] {
    $element = `$elements[1]`;
    $free-variables = free-variables (#element = $element);
    if [$free-variables = ""] {
      append-free-variables (#elements = `$elements[position() > 1]`);
    } else {
      if [starts-with ($free-variables, ",")] {
        $free-in-tail = append-free-variables (#elements = `$elements[position() > 1]`);
        if [$free-in-tail = ""] {
          $free-variables;
        } else {
          if [starts-with ($free-in-tail, ",")] {
            $free-in-tail-minus-initial-comma = `substring-after ($free-in-tail, ",")`;
            `concat ($free-variables, $free-in-tail-minus-initial-comma)`;
          } else {
            die (#message = "While computing the list of free variables of a list of elements, we found that the list of free variables for the tail of the list is a string that doesn't start with a comma (,) as we expected.");
          }
        }
      } else {
        die (#message = "While computing the list of free variables of a list of elements, we found that the list of free variables for one of its terms is a string that doesn't start with a comma (,) as we expected.");
      }
    }
  } else {
    "";
  }
}

// #variables is a list of Variable elements that are somehow bound
// (by a reservation, by a universal quantifier, etc.).
// #free-variables is a list of id numbers of variables that are free
// inside the matrix of whatever is binding #variables.  The task is
// simply walk through this list and remove id numbers that are equal
// to the id numbers of variables in #variables
tpl bind-variables (#variables, #free-variables) {
  if [$variables] {
    $variable = `$variables[1]`;
    if [$variable/@idnr] {
      $idnr = `$variable/@idnr`;
      $token = `concat (",", $idnr, ",")`;
      if [contains ($free-variables, $token)] {
        $before-token = `substring-before ($free-variables, $token)`; // might be empty; does not end with a comma
        $after-token = `substring-after ($free-variables, $token)`; // might be empty; does not start with a comma
        // we will call this template again *without* taking a subset
        // of #variables, to deal with the case where the idnr of
        // $variable occurs multiple times in #free-variables
        if [$after-token = ""] {
          if [$before-token = ""] {
            "";
          } else {
            $trimmed-free-variables = `concat ($before-token, ",")`;
            bind-variables (#variables = $variables, #free-variables = $trimmed-free-variables);
          }
        } else {
          $trimmed-free-variables = `concat ($before-token, ",", $after-token)`;
          bind-variables (#variables = $variables, #free-variables = $trimmed-free-variables);
        }
      } else {
        bind-variables (#variables = `$variables[position() > 1]`,
                        #free-variables = $free-variables);
      }
    } else {
      die (#message = "We cannot bind a variable that lacks an idnr attribute!");
    }
  } else {
    $free-variables;
  }
}

// Binding variables in blocks

tpl [Block/Item] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `preceding-sibling::Item[@kind = "Loci-Declaration"]/*/Variable`,
                  #free-variables = $all-free);
}

// Reservations bind variables

tpl [Item[@kind = "Reservation"]] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `Variable`, #free-variables = $all-free);
}

tpl [Item[@kind = "Loci-Declaration"]] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `Implicitly-Qualified-Segment/Variable | Explicitly-Qualified-Segment/Variable`, #free-variables = $all-free);
}

// Private predicate definitions introduce free second-order variables, which I don't care about

tpl [Item[@kind = "Private-Predicate-Definition"]] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `Variable`, #free-variables = $all-free);
}

// Terms

tpl free-variables-of-idnr-bearing-context {
  if [@idnr] {
    $idnr = `@idnr`;
    `concat (",", $idnr, ",")`;
  } else {
    die (#message = "We expected an element to have an idnr attribute, but it doesn't");
  }
}

tpl free-variables-of-nr-bearing-context {
  if [@nr] {
    $nr = `@nr`;
    `concat (",", $nr, ",")`;
  } else {
    die (#message = "We expected an element to have an nr attribute, but it doesn't");
  }
}

tpl [Simple-Term] mode="free-variables" {
  free-variables-of-idnr-bearing-context ();
}

tpl [Variable] mode="free-variables" {
  free-variables-of-idnr-bearing-context ();
}

tpl [Locus] mode="free-variables" {
  free-variables-of-nr-bearing-context ();
}

// default aggregation of free-variables

tpl [*] mode="free-variables" {
  append-free-variables (#elements = `*`);
}

// Formulas

tpl [Universal-Quantifier-Formula] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `Implicitly-Qualified-Segment/Variable | Explicitly-Qualified-Segment/Variable`,
                  #free-variables = $all-free);
}

tpl [Existential-Quantifier-Formula] mode="free-variables" {
  $all-free = append-free-variables (#elements = `*`);
  bind-variables (#variables = `Implicitly-Qualified-Segment/Variable | Explicitly-Qualified-Segment/Variable`,
                  #free-variables = $all-free);
}
