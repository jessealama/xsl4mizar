stylesheet 1.0;

output method=xml indent="yes";

include die.xsl;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl count-preceding-eliminable-toplevel-items {
  `count (preceding::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or @kind = "Private-Predicate-Definition" or (@kind = "Regular-Statement" and child::Diffuse-Statement) or (@kind = "Regular-Statement" and child::Proposition[descendant::Simple-Term/@idnr = preceding::Item[parent::Text-Proper and @kind = "Constant-Definition"]/Variable/@idnr or descendant::Simple-Term/@idnr = preceding::Item[parent::Text-Proper and @kind = "Type-Changing-Statement"]/Equality/Variable/@idnr or descendant::Simple-Term/@idnr = preceding::Item[parent::Text-Proper and @kind = "Type-Changing-Statement"]/Variable/@idnr])] | preceding::Item[@kind = "Loci-Declaration"])`;
}

tpl [Text-Proper/Item[@kind = "Reservation"]] {
  $type = `*[position() = last()]`;
<<<<<<< HEAD
  $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"])`;
  for-each [Variables] {
    if [Variable] {
      for-each [Variable] {
        <Item {
          for-each [@*] { copy-of `.`; }
          @kind = "Reservation";
          @toplevel-binder-number = `position() + $num-previous-toplevel`;
          if [@idnr] {
            @idnr = `@idnr`;
          } else {
            die (#message = "We found a variable that lacks an idnr attribute; unable to proceed.");
          }
          <Variables {
            apply [.];
          }
          apply [$type];
        }
=======
  $num-previous-toplevel = count-preceding-eliminable-toplevel-items ();
  for-each [Variable] {
    <Item {
      for-each [@*] { copy-of `.`; }
      @kind = "Reservation";
      @toplevel-binder-number = `position() + $num-previous-toplevel`;
      if [@idnr] {
        @idnr = `@idnr`;
      } else {
        die (#message = "We found a variable that lacks an idnr attribute; unable to proceed.");
>>>>>>> develop
      }
    } else {
      die (#message = "We expected to find at least one Variable child of a Variables element, but there are no such children");
    }
  }
}

tpl [Text-Proper/Item[@kind = "Private-Predicate-Definition" or @kind = "Private-Functor-Definition" or @kind = "Constant-Definition"]] {
  if [Variable[2]] {
    die (#message = "We assume that private predicate/functor definitions bind at most one variable, but we found one that binds at least two!");
  }
  <Item {
    for-each [@*] { copy-of `.`; }
<<<<<<< HEAD
    @toplevel-binder-number = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"]) + 1`;
=======
    $num-previous = count-preceding-eliminable-toplevel-items ();
    @toplevel-binder-number = `$num-previous + 1`;
>>>>>>> develop
    @idnr = `Variable[1]/@idnr`;
    apply [*];
  }
}

<<<<<<< HEAD
// These kinds of statements present problems for my analysis.  One can introduce spurious variables and types, e.g.:
//
// consider A being set, B being Jordan-Curve such that A1: A = B or A <> B;
//
// Lm: <something about A alone, not B>
//
// I can't just split up the choice statement into two separate ones
// because the property that the introduced variables satisfy involves
// both variables (A and B occur in "A = B or A <> B")
tpl [Text-Proper/Item[@kind = "Choice-Statement"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    @toplevel-binder-number = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"]) + 1`;
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement"]] {
  $type = `*[position() = last()]`;
  $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"])`;
  for-each [Variable] {
=======
tpl [Text-Proper/Item[@kind = "Type-Changing-Statement" and child::Equality]] {
  $num-children = `count (*)`;
  $justification = `*[position() = $num-children]`;
  $num-children-minus-one = `$num-children - 1`;
  $type = `*[position() = $num-children-minus-one]`;
  $num-previous-toplevel = count-preceding-eliminable-toplevel-items ();
  for-each [Equality] {
    $variable = `Variable`;
    $variable-idnr = `$variable/@idnr`;
    $definiens = `*[position() = last()]`;
>>>>>>> develop
    <Item {
      for-each [@*] { copy-of `.`; }
      @kind = "Type-Changing-Statement";
      @toplevel-binder-number = `position() + $num-previous-toplevel`;
      @idnr = $variable-idnr;
      <Equality {
        apply [$variable];
        apply [$definiens];
      }
      apply [$type];
      apply [$justification];
    }
  }
}

<<<<<<< HEAD
tpl [Text-Proper/Item[@kind = "Regular-Statement"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    if [Label] {
      @idnr = `Label[1]/@idnr`;
    } else {
      @idnr = "";
    }
    if [@shape = "Diffuse-Statement"] {
      $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"])`;
      @toplevel-binder-number = `$num-previous-toplevel + 1`;
    }
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind = "Constant-Definition"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    @idnr = `Variable[1]/@idnr`;
    $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"])`;
=======
tpl [Text-Proper/Item[@kind = "Type-Changing-Statement" and not(child::Equality)]] {
  $num-children = `count (*)`;
  $justification = `*[position() = $num-children]`;
  $num-children-minus-one = `$num-children - 1`;
  $type = `*[position() = $num-children-minus-one]`;
  $num-previous-toplevel = count-preceding-eliminable-toplevel-items ();
  $variable = `Variable`;
  $variable-idnr = `$variable/@idnr`;
  <Item {
    for-each [@*] { copy-of `.`; }
    @kind = "Type-Changing-Statement";
>>>>>>> develop
    @toplevel-binder-number = `$num-previous-toplevel + 1`;
    @idnr = $variable-idnr;
    apply [$variable];
    apply [$type];
    apply [$justification];
  }
}

tpl [Text-Proper/Item[@kind = "Regular-Statement"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
<<<<<<< HEAD
    @idnr = `Equality/Variable[1]/@idnr`;
    $num-previous-toplevel = `count (preceding-sibling::Item[@kind = "Reservation" or @kind = "Private-Functor-Definition" or @kind = "Choice-Statement" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind = "Regular-Statement" and @shape = "Diffuse-Statement")] | preceding::Item[@kind = "Loci-Declaration"])`;
=======
    choose {
      when [Proposition/Label] {
        @idnr = `Proposition/Label[1]/@idnr`;
      }
      when [Diffuse-Statement and Label] {
        @idnr = `Label[1]/@idnr`;
      }
      otherwise {
        @idnr = "";
      }
    }
    $num-previous-toplevel = count-preceding-eliminable-toplevel-items ();
>>>>>>> develop
    @toplevel-binder-number = `$num-previous-toplevel + 1`;
    apply [*];
  }
}

// tpl [Item[@kind = "Constant-Definition"]] {
//   <Item {
//     for-each [@*] { copy-of `.`; }
//     @idnr = `Variable[1]/@idnr`;
//     $num-previous-toplevel = count-preceding-eliminable-toplevel-items ();
//     @toplevel-binder-number = `$num-previous-toplevel + 1`;
//     apply [*];
//   }
// }

tpl [Item[@kind = "Loci-Declaration"]] {
  $loci = `.`;
<<<<<<< HEAD
  if [Implicitly-Qualified-Segment] {
    for-each [Implicitly-Qualified-Segment] {
      if [Variable] {
        for-each [Variable] {
          <Item {
            for-each [$loci/@*] { copy-of `.`; }
            $num_preceding = `count (preceding::Item[@kind = "Loci-Declaration"] | preceding::Item[@kind = "Reservation"] | preceding::Item[@kind = "Private-Functor-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Choice-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Constant-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Type-Changing-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Regular-Statement" and @shape = "Diffuse-Statement" and parent::Text-Proper])`;
            @toplevel-binder-number = `$num_preceding + 1`;
            @idnr = `@idnr`;
            <Implicitly-Qualified-Segment {
              apply [.]; // variable
            }
          }
        }
      } else {
        die (#message = "We expected to find at least one Variable child of the current Variables element, but there is no such child");
      }
    }
  }
  if [Explicitly-Qualified-Segment] {
    for-each [Explicitly-Qualified-Segment] {
      if [Variables] {
        for-each [Variables] {
          if [Variable] {
            for-each [Variable] {
              <Item {
                for-each [$loci/@*] { copy-of `.`; }
                $num_preceding = `count (preceding::Item[@kind = "Loci-Declaration"] | preceding::Item[@kind = "Reservation"] | preceding::Item[@kind = "Private-Functor-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Choice-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Constant-Definition" and parent::Text-Proper] | preceding::Item[@kind = "Type-Changing-Statement" and parent::Text-Proper] | preceding::Item[@kind = "Regular-Statement" and @shape = "Diffuse-Statement" and parent::Text-Proper])`;
                @toplevel-binder-number = `$num_preceding + 1`;
                @idnr = `@idnr`;
                <Explicitly-Qualified-Segment {
                  <Variables {
                    apply [.]; // variable
                  }
                  apply [../../*[position() = last()]]; // the type of the variable
                }
              }
            }
          } else {
            die (#message = "We expected to find at least one Variable child of the current Variables element, but there is no such child");
=======
  for-each [Implicitly-Qualified-Segment | Explicitly-Qualified-Segment] {
    $segment_element_name = `local-name (.)`;
    for-each [Variable] {
      <Item {
        for-each [$loci/@*] { copy-of `.`; }
        $num_preceding = count-preceding-eliminable-toplevel-items ();
        @toplevel-binder-number = `$num_preceding + 1`;
        @idnr = `@idnr`;
        <$segment_element_name {
          apply [.]; // variable
          if [$segment_element_name = "Explicitly-Qualified-Segment"] {
            apply [../*[position() = last()]]; // the type of the variable
>>>>>>> develop
          }
        }
      } else {
          die (#message = "We expected to find a Variables child of the current Explicitly-Qualified-Segment child, but there is no such child.");
      }
    }
  }
}

tpl [Item[@kind="Definition-Item"]] {
  $context = `.`;
  apply [Block] (#context = $context);
}

tpl [Block[@kind="Definitional-Block"]] (#context) {
  apply [Item[@kind = "Attribute-Definition" or @kind = "Functor-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition" or @kind = "Structure-Definition"]](#definitions = `Item[@kind = "Private-Predicate-Definition" or @kind="Private-Functor-Definition"]`, #context = $context);
}

tpl [Block[@kind = "Registration-Block"]] {
  apply [Item[@kind = "Cluster"]];
}

tpl [Block[@kind = "Notation-Block"]] {
  apply [Item[@kind = "Pred-Antonym" or @kind = "Pred-Synonym" or @kind = "Attr-Antonym" or @kind = "Attr-Synonym" or @kind = "Func-Synonym" or @kind = "Func-Antonym" or @kind = "Mode-Synonym" or @kind = "Mode-Antonym"]];
}

tpl [Item[@kind = "Cluster"]] {
  <Item {
    @kind = "Definition-Item";
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    <Block {
      @kind = "Registration-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = "Cluster";
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl correctness-conditions (#candidates, #definitions, #stop) {
  if [not($stop = "1")] {
    if [$candidates] {
      $candidate = `$candidates[1]`;
      for-each [$candidate] {
        $candidate_name = `local-name(.)`;
        $candidate_kind = `$candidate/@kind`;
        if [$candidate_name = "Item" and ($candidate_kind = "Correctness-Condition" or $candidate_kind = "Property" or $candidate_kind = "Correctness")] {
          apply [$candidate](#definitions = $definitions);
          correctness-conditions (#candidates = `$candidates[position() > 1]`,
                                  #definitions = $definitions);
        } else {
          correctness-conditions (#stop = "1");
        }
      }
    }
  }
}

tpl [Item[@kind = "Correctness-Condition" or @kind = "Property" or @kind = "Correctness"]](#definitions) {
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*](#definitions = $definitions);
  }
}

tpl [Item[@kind = "Theorem-Item"]] {
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Block[@kind = "Proof"]](#definitions) {
  $context = `.`;
  <Block {
    @kind = "Proof";
    if [$definitions] {
      for-each [$definitions] {
        if [Variable] {
          $idnr = `Variable[1]/@idnr`;
          if [$context//Private-Predicate-Formula[@idnr = $idnr] or $context//Private-Functor-Term[@idnr = $idnr]] {
            copy-of `.`;
          }
        } else {
          die (#message = "While determining whether to possibly include some local definitions into a proof, we encountered a local definition that lacks a Variable child");
        }
      }
    }
    apply [*];
  }
}

tpl [Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition" or @kind = "Mode-Definition" or @kind = "Structure-Definition"]](#definitions, #context) {
  <Item {
<<<<<<< HEAD
    for-each [@*] { copy-of `.`; }
=======
    for-each [$context/@*] { copy-of `.`; }
>>>>>>> develop
    @kind = "Definition-Item";
    <Block {
      @kind = "Definitional-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration" or @kind = "Assumption" or @kind = "Existential-Assumption" or @kind = "Constant-Definition"]] {
        apply [.];
      }
      <Item {
        for-each [@*] { copy-of `.`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`, #definitions = $definitions);
    }
  }
}

tpl [Item[@kind = "Pred-Synonym" or @kind = "Pred-Antonym" or @kind = "Attr-Synonym" or @kind = "Attr-Antonym" or @kind = "Func-Synonym" or @kind = "Func-Antonym" or @kind = "Mode-Synonym" or @kind = "Mode-Antonym"]] {
  <Item {
    @kind = "Definition-Item";
    <Block {
      @kind = "Notation-Block";
      for-each [preceding-sibling::Item[@kind = "Loci-Declaration"]] {
        apply [.];
      }
      <Item {
        @kind = `@kind`;
        if [@line] { @line = `@line`; }
        if [@col] { @col = `@col`; }
        apply [*];
      }
      correctness-conditions (#candidates = `following-sibling::*`);
    }
  }
}

tpl split-explicitly-qualified-segment (#variables, #type) {
  if [$variables] {
    $variable = `$variables[1]`;
    <Explicitly-Qualified-Segment {
      <Variables {
        apply [$variable];
      }
      apply [$type];
    }
    split-explicitly-qualified-segment (#variables = `$variables[position() > 1]`,
                                        #type = $type);
  }
}

<<<<<<< HEAD
tpl [Explicitly-Qualified-Segment] {
  split-explicitly-qualified-segment (#variables = `Variables/Variable`,
=======
tpl [Explicitly-Qualified-Segment[not(parent::Item[@kind = "Choice-Statement"])]] {
  split-explicitly-qualified-segment (#variables = `Variable`,
>>>>>>> develop
                                      #type = `*[position() = last()]`);
}

// don't break up explicitly qualified segments inside universal formulas...yet
tpl [Universal-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}

tpl [Existential-Quantifier-Formula/Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}