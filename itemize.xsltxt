stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [Text-Proper] {
  <Text-Proper {
    apply [*];
  }
}

tpl ensure-spelling {
  if [not(@spelling)] {
    die (#message = "We expected an element to have a spelling attribute, but it lacks one");
  }
}

tpl [Variable] {
  <Variable {
    @spelling = `@spelling`;
    @idnr = `@idnr`;
  }
}

tpl [Internal-Selector-Term] {
  <Internal-Selector-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Standard-Type] {
  <Standard-Type {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Item[@kind='Reservation']] {
  // do nothing: We will manage variable reservations ourselves
}

tpl [Item[@kind='Section-Pragma']] {
  <Item {
    @kind = "Section-Pragma";
  }
}

tpl [Item[@kind='Per-Cases']] {
  <Item {
    @kind = "Per-Cases";
    apply [*];
  }
}

tpl [Item[@kind='Case-Block']] {
  <Item {
    @kind = "Case-Block";
    apply [*];
  }
}

tpl [Block[@kind='Case']] {
  <Block {
    @kind = "Case";
    apply [*];
  }
}

tpl [Block[@kind='Suppose']] {
  <Block {
    @kind = "Suppose";
    apply [*];
  }
}

tpl [Item[@kind='Case-Head']] {
  <Item {
    @kind = "Case-Head";
    apply [*];
  }
}

tpl [Item[@kind='Suppose-Head']] {
  <Item {
    @kind = "Suppose-Head";
    apply [*];
  }
}

tpl copy-children {
  for-each [*] {
    copy-of `.`;
  }
}

tpl first-one(#elems) {
  copy-of `$elems[1]`;
}

key "V" [Variable] `@spelling`;

tpl emit-unqualified-variables {
  if [//Implicitly-Qualified-Segment/Variable] {
    "\n";
  }
  for-each [//Implicitly-Qualified-Segment/Variable[not(@spelling = preceding::Implicitly-Qualified-Segment/Variable/@spelling)]] {
    copy-of `.`; "\n";
  }
}

tpl [Item[@kind='Scheme-Block-Item']] {
  <Item {
    @kind="Scheme-Block-Item";
    apply [*];
  }
}

tpl [Block[@kind='Scheme-Block']] {
  <Block {
    @kind = "Scheme-Block";
    apply [*];
  }
}

tpl [Item[@kind='Definition-Item']] {
  <Item {
    @kind="Definition-Item";
    apply [*];
  }
}

tpl [Type-Specification] {
  <Type-Specification {
    apply [*];
  }
}

tpl [Equals] {
  <Equals;
}

tpl [Means] {
  <Means;
}

tpl [Formula-Expression] {
  <Formula-Expression;
}

tpl [Term-Expression] {
  <Term-Expression;
}

tpl [it-Term] {
  <it-Term;
}

// Standard-Mode elements suck
tpl [Standard-Mode] {
  <Standard-Mode {
    apply [*];
  }
}

tpl [Expandable-Mode] {
  <Expandable-Mode {
    apply [*];
  }
}

tpl [Item[@kind='Mode-Definition']] {
  <Item {
    @kind = "Mode-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Predicate-Definition']] {
  <Item {
    @kind = "Predicate-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Functor-Definition']] {
  <Item {
    @kind = "Functor-Definition";
    apply [*];
  }
}

tpl [Predicate-Pattern] {
  <Predicate-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Mode-Pattern] {
  <Mode-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Operation-Functor-Pattern] {
  <Operation-Functor-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Block[@kind='Definitional-Block']] {
  <Block {
    @kind="Definitional-Block";
    apply [*];
  }
}

tpl [Block[@kind='Registration-Block']] {
  <Block {
    @kind="Registration-Block";
    apply [*];
  }
}

tpl [Item[@kind='Identify']] {
  <Item {
    @kind = "Identify";
    apply [*];
  }  
}

tpl [Item[@kind='Cluster']] {
  <Item {
    @kind = "Cluster";
    apply [*];
  }
}

tpl [Existence] {
  <Existence;
}

tpl [Uniqueness] {
  <Uniqueness;
}

tpl [Coherence] {
  <Coherence;
}

tpl [Block[@kind='Proof']] {
  <Block {
    @kind = "Proof";
    $parent_name = `local-name(parent::*)`;
    $parent_kind = `../@kind`;
    if [$parent_name = "Item" and $parent_kind = "Correctness-Condition"] {
      apply [*](#generalize = "1");
    } else {
      generalize-proof ();
      apply [*](#generalize = "0");
    }
  }
}

tpl [Compatibility] {
  <Compatibility;
}

tpl [Consistency] {
  <Consistency;
}

tpl [Item[@kind='Correctness-Condition']] {
  <Item {
    @kind = "Correctness-Condition";
    apply [*];
  }
}

tpl [Adjective] {
  <Adjective {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Adjective-Cluster] {
  <Adjective-Cluster {
    apply [*];
  }
}

tpl [Existential-Registration] {
  <Existential-Registration {
    apply [*];
  }
}

tpl [Functorial-Registration] {
  <Functorial-Registration {
    apply [*];
  }
}

tpl [Conditional-Registration] {
  <Conditional-Registration {
    apply [*];
  }
}

tpl [Item[@kind='Loci-Declaration']] {
  <Item {
    @kind="Loci-Declaration";
    apply [*];
  }
}

tpl [Formula-Expression] {
  <Formula-Expression;
}

tpl [Term-Expression] {
  <Term-Expression;
}

tpl [Definiens] {
  <Definiens {
    apply [*](#generalize = "1");
  }
}

tpl [Partial-Definiens] {
  <Partial-Definiens {
    apply [*];
  }
}

tpl [Qualifying-Formula] {
  <Qualifying-Formula {
    apply [*];
  }
}

tpl [Negated-Formula] {
  <Negated-Formula {
    apply [*];
  }
}

tpl [Item[@kind='Attribute-Definition']] {
  <Item {
    @kind="Attribute-Definition";
    apply [*];
  }
}

tpl [Loci] {
  <Loci {
    apply [*];
  }
}

tpl [Locus] {
  <Locus { 
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Attribute-Pattern] {
  <Attribute-Pattern {
    @spelling=`@spelling`;
    apply [*];
  }
}

tpl [Type-List] {
  <Type-List {
    apply [*];
  }
}

tpl [Functor-Segment] {
  <Functor-Segment {
    apply [*];
  }
}

tpl [Predicate-Segment] {
  <Predicate-Segment {
    apply [*];
  }
}

tpl [Scheme] {
  <Scheme {
    @spelling = `@spelling`;
  }
}

tpl [Implicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    for-each [Variable] {
      $spelling = `@spelling`;
      apply [.];
      if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
        apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type];
      } else {
        die (#message = "Could not determine type of an implicitly qualified variable!");
      }
    }
  }
}

tpl [Selector] {
  <Selector {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Field-Segment] {
  <Field-Segment {
    apply [*];
  }
}

tpl [Structure-Pattern] {
  <Structure-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Ancestors] {
  <Ancestors {
    apply [*];
  }
}

tpl [Item[@kind='Structure-Definition']] {
  <Item {
    @kind = "Structure-Definition";
    apply [*];
  }
}

tpl [Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}

tpl [Simple-Term] {
  <Simple-Term {
    @spelling=`@spelling`;
    apply [*];
  }
}

tpl [Forgetful-Functor-Term] {
  <Forgetful-Functor-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Aggregate-Term] {
  <Aggregate-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Selector-Term] {
  <Selector-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Arguments] {
  <Arguments {
    apply [*];
  }
}

tpl [Numeral-Term] {
  <Numeral-Term {
    @"number" = `@number`;
  }
}

tpl [Private-Functor-Term] {
  <Private-Functor-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Contradiction] {
  <Contradiction;
}

tpl [Global-Choice-Term] {
  <Global-Choice-Term {
    apply [*];
  }
}

tpl [Struct-Type] {
  <Struct-Type {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Clustered-Type] {
  <Clustered-Type {
    apply [*];
  }
}

tpl [Item[@kind='Constant-Definition']] {
  <Item {
    @kind="Constant-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Private-Functor-Definition']] {
  <Item {
    @kind = "Private-Functor-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Private-Predicate-Definition']] {
  <Item {
    @kind = "Private-Predicate-Definition";
    apply [*];
  }
}

tpl [Theorem-Reference] {
  <Theorem-Reference {
    @spelling = `@spelling`;
    @"number" = `@number`;
    apply [*];
  }
}

tpl [Definition-Reference] {
  <Definition-Reference {
    @"number" = `@number`;
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Item[@kind='Exemplification']] {
  <Item {
    @kind="Exemplification";
    apply [*];
  }
}

tpl [Item[@kind='Generalization']] {
  <Item {
    @kind="Generalization";
    apply [*];
  }
}

// Formulas

// Generalizing free variables

tpl generalize-helper(#candidates, #seen) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = $candidate/@spelling;
    $free = occurs-freely (#variable = $candidate);
    if [$free = "0"] {
      generalize-helper(#candidates = `$candidates[position() > 1]`,
                        #seen = $seen);
    } else {
      $var_token = `concat ($spelling, ",")`;
      if [contains ($seen, $var_token)] {
        generalize-helper(#candidates = `$candidates[position() > 1]`,
                          #seen = `concat ($seen, $spelling, ",")`);
      } else {
        if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variable {
                @spelling = $spelling;
                @elicited = "elicited";
              }
              apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type];
            }
            generalize-helper(#candidates = `$candidates[position() > 1]`,
                              #seen = `concat ($seen, $spelling, ",")`);
          }
        } else {
          die (#message = "Could not determine type of an implicitly qualified variable!");
        }
      }
    }
  } else {
    apply [.](#generalize = "0");
  }
}

// Assumes the context node is a formula of some kind
tpl generalize {
  generalize-helper(#candidates = `.//Simple-Term`,
                    #seen = "");
}

// Assumes that the context node is a proof block
tpl generalize-proof-helper(#candidates, #seen) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = $candidate/@spelling;
    $free = occurs-freely (#variable = $candidate); 
    if [$free = "0"] {
      generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                              #seen = $seen);
    } else {
      $var_token = `concat ($spelling, ",")`;
      if [contains ($seen, $var_token)] {
        generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                                #seen = `concat ($seen, $spelling, ",")`);
      } else {
        if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
          <Item {
            @kind = "Loci-Declaration";        
            <Explicitly-Qualified-Segment {
              <Variable {
                @spelling = $spelling;
                @elicited = "elicited";
              }
              apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type];
            }
          }
          generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                                  #seen = `concat ($seen, $spelling, ",")`);
        } else {
          die (#message = "Could not determine type of an implicitly qualified variable!");
        }
      }
    }
  }
}

tpl generalize-proof {
  generalize-proof-helper(#candidates = `../Proposition//Simple-Term`,
                          #seen = "");
}

// Atoms

tpl [Attributive-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Attributive-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Predicative-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Predicative-Formula {
      @spelling=`@spelling`;
      apply [*](#generalize = "0");
    }
  }
}

tpl [Private-Predicate-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Private-Predicate-Formula {
      @spelling = `@spelling`;
      apply [*](#generalize = "0");
  }
  }
}

// Complex formulas

tpl [Conjunctive-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Conjunctive-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Disjunctive-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Disjunctive-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Conditional-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Conditional-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Biconditional-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Biconditional-Formula {
      apply [*](#generalize = "0");
    }
  }
}

// Quantifed formulas

tpl [Universal-Quantifier-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Universal-Quantifier-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Existential-Quantifier-Formula](#generalize) {
  if [$generalize = "1"] {
    generalize ();
  } else {
    <Existential-Quantifier-Formula {
      apply [*](#generalize = "0");
    }
  }
}

tpl [Placeholder-Term] {
  <Placeholder-Term {
    @spelling = `@spelling`;
  }  
}

tpl [Thesis] {
  <Thesis;
}

tpl [Item[@kind='PropertyRegistration']] { // shouldn't this be "Property-Registration", for parallelism?
  <Item {
    @kind = "PropertyRegistration";
    apply [*];
  }
}

tpl [Item[@kind='Property']] {
  <Item {
    @kind = "Property";
    apply [*];
  }
}

tpl [Item[@kind="Correctness"]] {
  <Item {
    @kind = "Correctness";
    apply [*];
  }
}

tpl occurs-freely(#variable, #val) {
  if [$val] {
    $val;
  } else {
    $spelling = $variable/@spelling;
    for-each [$variable] { // kludge to force $variable to be the context node
      if [not(ancestor::Universal-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Universal-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Existential-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Existential-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Constant-Definition"]/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Choice-Statement"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Choice-Statement"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Generalization"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Generalization"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Loci-Declaration"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Loci-Declaration"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])] {
        occurs-freely (#val = "1");
      } else {
        occurs-freely (#val = "0");
      }
    }
  }
}

tpl [Proposition](#generalize) {
  <Proposition {
    apply [*](#generalize = $generalize);
  }
}

tpl [Label] {
  <Label {
    @spelling = `@spelling`;
  }
}

tpl [Link] {
  <Link;
}

tpl [Local-Reference] {
  ensure-spelling ();
  <Local-Reference {
    @spelling=`@spelling`;
  }
}

tpl [Scheme-Justification] {
  <Scheme-Justification {
    @spelling = `@spelling`;
    @idnr = `@idnr`;
    @nr = `@nr`;
    apply [*];
  }
}

tpl [Infix-Term] {
  <Infix-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Bracket-Functor-Pattern] {
  <Bracket-Functor-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Fraenkel-Term] {
  <Fraenkel-Term {
    apply [*];
  }
}

tpl [Circumfix-Term] {
  <Circumfix-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Right-Circumflex-Symbol] {
  <Right-Circumflex-Symbol {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Qualification-Term] {
  <Qualification-Term {
    apply [*];
  }
}

tpl [Item[@kind='Choice-Statement']](#generalize) {
  <Item {
    @kind="Choice-Statement";
    apply [*](#generalize = $generalize);
  }
}

tpl [Straightforward-Justification] {
  <Straightforward-Justification {
    apply [*];
  }
}

// Constructor properties

tpl [Projectivity] {
  <Projectivity;
}

tpl [Involutiveness] {
  <Involutiveness;
}

tpl [Idempotence] {
  <Idempotence;
}

tpl [Commutativity] {
  <Commutativity;
}

tpl [Reflexivity] {
  <Reflexivity;
}

tpl [Irreflexivity] {
  <Irreflexivity;
}

tpl [Symmetry] {
  <Symmetry;
}

tpl [Asymmetry] {
  <Asymmetry;
}

tpl [Connectedness] {
  <Connectedness;
}

tpl [Sethood] {
  <Sethood;
}

tpl [Compact-Statement] {
  <Compact-Statement;
}

tpl [Diffuse-Statement] {
  <Diffuse-Statement;
}

tpl [Iterative-Equality] {
  <Iterative-Equality;
}

tpl [Single-Assumption](#generalize) {
  <Single-Assumption {
    apply [*](#generalize = $generalize);
  }
}

tpl [Item[@kind='Assumption']](#generalize) {
  <Item {
    @kind = "Assumption";
    apply [*](#generalize = $generalize);
  }
}

tpl [Iterative-Step] {
  <Iterative-Step {
    apply [*];
  }
}

tpl [Collective-Assumption](#generalize) {
  <Collective-Assumption {
    apply [*](#generalize = $generalize);
  }
}

tpl [Item[@kind='Existential-Assumption']] {
  <Item {
    @kind = "Existential-Assumption";
    apply [*];
  }
}

tpl [Item[@kind='Conclusion']] {
  <Item {
    @kind = "Conclusion";
    apply [*];
  }
}

tpl [Item[@kind='Mode-Synonym']] {
  <Item {
    @kind = "Mode-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Func-Synonym']] {
  <Item {
    @kind = "Func-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Attr-Synonym']] {
  <Item {
    @kind = "Attr-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Pred-Synonym']] {
  <Item {
    @kind = "Pred-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Attr-Antonym']] {
  <Item {
    @kind = "Attr-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Pred-Antonym']] {
  <Item {
    @kind = "Pred-Antonym";
    apply [*];
  }
}

tpl [Block[@kind='Notation-Block']] {
  <Block {
    @kind = "Notation-Block";
    apply [*];
  }
}

tpl [Item[@kind='Theorem-Item']] {
  <Item {
    @kind="Theorem-Item";
    apply [*](#generalize = "1");
  }
}

tpl [Block[@kind='Now-Reasoning']] {
  <Block {
    @kind = "Now-Reasoning";
    apply [*];
  }
}

tpl [Block[@kind='Hereby-Reasoning']] {
  <Block {
    @kind = "Hereby-Reasoning";
    apply [*];
  }
}

tpl [Item[@kind='Type-Changing-Statement']] {
  <Item {
    @kind = "Type-Changing-Statement";
    apply [*];
  }
}

tpl [Equality] {
  <Equality {
    apply [*];
  }
}

tpl [Item[@kind='Regular-Statement']](#generalize) {
  $parent_name = `local-name (parent::*)`;
  if [$parent_name = "Text-Proper"] {
    <Item {
      @kind = "Regular-Statement";
      apply [*[1]]; // should be Compact-Statement, Diffuse-Statement, or Iterative-Equality
      apply [Proposition[1]](#generalize = "1");
      if [Straightforward-Justification | Scheme-Justification] {
        apply [(Straightforward-Justification | Scheme-Justification)[1]];
      } else {
        if [Block[@kind='Proof']] {
          apply [Block[@kind='Proof'][1]];
        } else {
          die (#message = "Don't know how to deal with a Regular-Statement item that lacks a Straightforward-Justification, a Scheme-Justification, and a Proof block");
        }
      }
    }
  } else {
    <Item {
      @kind = "Regular-Statement";
      apply [*](#generalize = $generalize);
    }
  }
}

tpl [Schematic-Variables] {
  <Schematic-Variables {
    apply [*];
  }
}

tpl [Provisional-Formulas] {
  <Provisional-Formulas {
    apply [*];
  }
}

tpl [Item[@kind='Scheme-Head']] {
  <Item {
    @kind = "Scheme-Head";
    apply [*];
  }
}

tpl [Redefine] {
  <Redefine;
}

tpl [Negated] {
  <Negated;
}