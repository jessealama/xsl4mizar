stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [Text-Proper] {
  <Text-Proper {
    apply [*];
  }
}

tpl ensure-spelling {
  if [not(@spelling)] {
    die (#message = "We expected an element to have a spelling attribute, but it lacks one");
  }
}

tpl [Variable] {
  <Variable {
    @spelling = `@spelling`;
    @idnr = `@idnr`;
  }
}

tpl [Internal-Selector-Term] {
  <Internal-Selector-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Standard-Type] {
  <Standard-Type {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Item[@kind='Reservation']] {
  // do nothing: We will manage variable reservations ourselves
}

tpl [Item[@kind='Section-Pragma']] {
  <Item {
    @kind = "Section-Pragma";
  }
}

tpl [Item[@kind='Per-Cases']] {
  <Item {
    @kind = "Per-Cases";
    apply [*];
  }
}

tpl [Item[@kind='Case-Block']] {
  <Item {
    @kind = "Case-Block";
    apply [*];
  }
}

tpl [Block[@kind='Case']] {
  <Block {
    @kind = "Case";
    apply [*];
  }
}

tpl [Block[@kind='Suppose']] {
  <Block {
    @kind = "Suppose";
    apply [*];
  }
}

tpl [Item[@kind='Case-Head']] {
  <Item {
    @kind = "Case-Head";
    apply [*];
  }
}

tpl [Item[@kind='Suppose-Head']] {
  <Item {
    @kind = "Suppose-Head";
    apply [*];
  }
}

tpl copy-children {
  for-each [*] {
    copy-of `.`;
  }
}

tpl first-one(#elems) {
  copy-of `$elems[1]`;
}

key "V" [Variable] `@spelling`;

tpl emit-unqualified-variables {
  if [//Implicitly-Qualified-Segment/Variable] {
    "\n";
  }
  for-each [//Implicitly-Qualified-Segment/Variable[not(@spelling = preceding::Implicitly-Qualified-Segment/Variable/@spelling)]] {
    copy-of `.`; "\n";
  }
}

tpl [Item[@kind='Scheme-Block-Item']] {
  <Item {
    @kind="Scheme-Block-Item";
    apply [*];
  }
}

tpl [Block[@kind='Scheme-Block']] {
  <Block {
    @kind = "Scheme-Block";
    apply [*];
  }
}

tpl [Item[@kind='Definition-Item']] {
  <Item {
    @kind="Definition-Item";
    apply [*];
  }
}

tpl [Type-Specification] {
  <Type-Specification {
    apply [*];
  }
}

tpl [Equals] {
  <Equals;
}

tpl [Means] {
  <Means;
}

tpl [Formula-Expression] {
  <Formula-Expression;
}

tpl [Term-Expression] {
  <Term-Expression;
}

tpl [it-Term] {
  <it-Term;
}

// Standard-Mode elements suck
tpl [Standard-Mode] {
  <Standard-Mode {
    apply [*];
  }
}

tpl [Expandable-Mode] {
  <Expandable-Mode {
    apply [*];
  }
}

tpl [Item[@kind='Mode-Definition']] {
  <Item {
    @kind = "Mode-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Predicate-Definition']] {
  <Item {
    @kind = "Predicate-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Functor-Definition']] {
  <Item {
    @kind = "Functor-Definition";
    apply [*];
  }
}

tpl [Predicate-Pattern] {
  <Predicate-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Mode-Pattern] {
  <Mode-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Operation-Functor-Pattern] {
  <Operation-Functor-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Block[@kind='Definitional-Block']] {
  <Block {
    @kind="Definitional-Block";
    apply [*];
  }
}

tpl [Block[@kind='Registration-Block']] {
  <Block {
    @kind="Registration-Block";
    apply [*];
  }
}

tpl [Item[@kind='Identify']] {
  <Item {
    @kind = "Identify";
    apply [*];
  }  
}

tpl [Item[@kind='Cluster']] {
  <Item {
    @kind = "Cluster";
    apply [*];
  }
}

tpl [Existence] {
  <Existence;
}

tpl [Uniqueness] {
  <Uniqueness;
}

tpl [Coherence] {
  <Coherence;
}

tpl [Block[@kind='Proof']] {
  <Block {
    @kind = "Proof";
    apply [*];
  }
}

tpl [Compatibility] {
  <Compatibility;
}

tpl [Consistency] {
  <Consistency;
}

tpl [Item[@kind='Correctness-Condition']] {
  <Item {
    @kind = "Correctness-Condition";
    apply [*];
  }
}

tpl [Adjective] {
  <Adjective {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Adjective-Cluster] {
  <Adjective-Cluster {
    apply [*];
  }
}

tpl [Existential-Registration] {
  <Existential-Registration {
    apply [*];
  }
}

tpl [Functorial-Registration] {
  <Functorial-Registration {
    apply [*];
  }
}

tpl [Conditional-Registration] {
  <Conditional-Registration {
    apply [*];
  }
}

tpl [Item[@kind='Loci-Declaration']] {
  <Item {
    @kind="Loci-Declaration";
    apply [*];
  }
}

tpl [Formula-Expression] {
  <Formula-Expression;
}

tpl [Term-Expression] {
  <Term-Expression;
}

tpl [Definiens] {
  <Definiens {
    apply [*];
  }
}

tpl [Partial-Definiens] {
  <Partial-Definiens {
    apply [*];
  }
}

tpl [Qualifying-Formula] {
  <Qualifying-Formula {
    apply [*];
  }
}

tpl [Negated-Formula] {
  <Negated-Formula {
    apply [*];
  }
}

tpl [Item[@kind='Attribute-Definition']] {
  <Item {
    @kind="Attribute-Definition";
    apply [*];
  }
}

tpl [Loci] {
  <Loci {
    apply [*];
  }
}

tpl [Locus] {
  <Locus { 
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Attribute-Pattern] {
  <Attribute-Pattern {
    @spelling=`@spelling`;
    apply [*];
  }
}

tpl [Type-List] {
  <Type-List {
    apply [*];
  }
}

tpl [Functor-Segment] {
  <Functor-Segment {
    apply [*];
  }
}

tpl [Predicate-Segment] {
  <Predicate-Segment {
    apply [*];
  }
}

tpl [Scheme] {
  <Scheme {
    @spelling = `@spelling`;
  }
}

tpl [Implicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    for-each [Variable] {
      $spelling = `@spelling`;
      apply [.];
      if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
        apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type];
      } else {
        die (#message = "Could not determine type of an implicitly qualified variable!");
      }
    }
  }
}

tpl [Selector] {
  <Selector {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Field-Segment] {
  <Field-Segment {
    apply [*];
  }
}

tpl [Structure-Pattern] {
  <Structure-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Ancestors] {
  <Ancestors {
    apply [*];
  }
}

tpl [Item[@kind='Structure-Definition']] {
  <Item {
    @kind = "Structure-Definition";
    apply [*];
  }
}

tpl [Explicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    apply [*];
  }
}

tpl [Simple-Term] {
  <Simple-Term {
    @spelling=`@spelling`;
    apply [*];
  }
}

tpl [Forgetful-Functor-Term] {
  <Forgetful-Functor-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Aggregate-Term] {
  <Aggregate-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Selector-Term] {
  <Selector-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Arguments] {
  <Arguments {
    apply [*];
  }
}

tpl [Numeral-Term] {
  <Numeral-Term {
    @"number" = `@number`;
  }
}

tpl [Private-Functor-Term] {
  <Private-Functor-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Contradiction] {
  <Contradiction;
}

tpl [Global-Choice-Term] {
  <Global-Choice-Term {
    apply [*];
  }
}

tpl [Struct-Type] {
  <Struct-Type {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Clustered-Type] {
  <Clustered-Type {
    apply [*];
  }
}

tpl [Item[@kind='Constant-Definition']] {
  <Item {
    @kind="Constant-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Private-Functor-Definition']] {
  <Item {
    @kind = "Private-Functor-Definition";
    apply [*];
  }
}

tpl [Item[@kind='Private-Predicate-Definition']] {
  <Item {
    @kind = "Private-Predicate-Definition";
    apply [*];
  }
}

tpl [Theorem-Reference] {
  <Theorem-Reference {
    @spelling = `@spelling`;
    @"number" = `@number`;
    apply [*];
  }
}

tpl [Definition-Reference] {
  <Definition-Reference {
    @"number" = `@number`;
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Item[@kind='Exemplification']] {
  <Item {
    @kind="Exemplification";
    apply [*];
  }
}

tpl [Item[@kind='Generalization']] {
  <Item {
    @kind="Generalization";
    apply [*];
  }
}

tpl [Private-Predicate-Formula] {
  ensure-spelling ();
  <Private-Predicate-Formula {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Conjunctive-Formula] {
  <Conjunctive-Formula {
    apply [*];
  }
}

tpl [Disjunctive-Formula] {
  <Disjunctive-Formula {
    apply [*];
  }
}

tpl [Conditional-Formula] {
  <Conditional-Formula {
    apply [*];
  }
}

tpl [Biconditional-Formula] {
  <Biconditional-Formula {
    apply [*];
  }
}

tpl [Placeholder-Term] {
  <Placeholder-Term {
    @spelling = `@spelling`;
  }  
}

tpl [Attributive-Formula] {
  <Attributive-Formula {
    apply [*];
  }
}

tpl [Predicative-Formula] {
  <Predicative-Formula {
    @spelling=`@spelling`;
    apply [*];
  }
}

tpl [Thesis] {
  <Thesis;
}

tpl [Item[@kind='PropertyRegistration']] { // shouldn't this be "Property-Registration", for parallelism?
  <Item {
    @kind = "PropertyRegistration";
    apply [*];
  }
}

tpl [Item[@kind='Property']] {
  <Item {
    @kind = "Property";
    apply [*];
  }
}

tpl [Item[@kind="Correctness"]] {
  <Item {
    @kind = "Correctness";
    apply [*];
  }
}

tpl occurs-freely(#variable, #val) {
  if [$val] {
    $val;
  } else {
    $spelling = $variable/@spelling;
    for-each [$variable] { // kludge to force $variable to be the context node
      if [not(ancestor::Universal-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Universal-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Existential-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Existential-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Constant-Definition"]/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Choice-Statement"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Choice-Statement"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Generalization"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Generalization"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Loci-Declaration"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling])
          and
          not(ancestor::Block/Item[@kind="Loci-Declaration"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])] {
        occurs-freely (#val = "1");
      } else {
        occurs-freely (#val = "0");
      }
    }
  }
}

tpl [Proposition](#initialized, #candidates, #seen) {
  if [$initialized] {
    if [$candidates] {
      $candidate = `$candidates[1]`;
      $spelling = $candidate/@spelling;
      $free = occurs-freely (#variable = $candidate);
      if [$free = "0"] {
        apply [.](#initialized = "1",
                  #candidates = `$candidates[position() > 1]`,
                  #seen = $seen);
      } else {
        $var_token = `concat ($spelling, ",")`;
        if [contains ($seen, $var_token)] {
          apply [.](#initialized = "1",
                    #candidates = `$candidates[position() > 1]`,
                    #seen = `concat ($seen, $spelling, ",")`);
        } else {
          <Universal-Quantifier-Formula {
            <Implicitly-Qualified-Segment {
              <Variable {
                @spelling = $spelling;
                @elicited = "elicited";
              }
            }
            apply [.](#initialized = "1",
                      #candidates = `$candidates[position() > 1]`,
                      #seen = `concat ($seen, $spelling, ",")`);
          }
        }
      }
    } else {
      <Proposition {
        apply [*];
      }
    }    
  } else {
    apply [.](#initialized = "1",
              #candidates = `.//Simple-Term`,
              #seen = "");
  }
}

tpl [Label] {
  <Label {
    @spelling = `@spelling`;
  }
}

tpl [Local-Reference] {
  ensure-spelling ();
  <Local-Reference {
    @spelling=`@spelling`;
  }
}

tpl [Scheme-Justification] {
  <Scheme-Justification {
    @spelling = `@spelling`;
    @idnr = `@idnr`;
    @nr = `@nr`;
    apply [*];
  }
}

tpl [Infix-Term] {
  <Infix-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Bracket-Functor-Pattern] {
  <Bracket-Functor-Pattern {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Fraenkel-Term] {
  <Fraenkel-Term {
    apply [*];
  }
}

tpl [Circumfix-Term] {
  <Circumfix-Term {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Right-Circumflex-Symbol] {
  <Right-Circumflex-Symbol {
    @spelling = `@spelling`;
    apply [*];
  }
}

tpl [Qualification-Term] {
  <Qualification-Term {
    apply [*];
  }
}

tpl [Item[@kind='Choice-Statement']] {
  <Item {
    @kind="Choice-Statement";
    apply [*];
  }
}

tpl [Straightforward-Justification] {
  <Straightforward-Justification {
    apply [*];
  }
}

// Constructor properties

tpl [Projectivity] {
  <Projectivity;
}

tpl [Involutiveness] {
  <Involutiveness;
}

tpl [Idempotence] {
  <Idempotence;
}

tpl [Commutativity] {
  <Commutativity;
}

tpl [Reflexivity] {
  <Reflexivity;
}

tpl [Irreflexivity] {
  <Irreflexivity;
}

tpl [Symmetry] {
  <Symmetry;
}

tpl [Asymmetry] {
  <Asymmetry;
}

tpl [Connectedness] {
  <Connectedness;
}

tpl [Sethood] {
  <Sethood;
}

tpl [Compact-Statement] {
  <Compact-Statement;
}

tpl [Diffuse-Statement] {
  <Diffuse-Statement;
}

tpl [Iterative-Equality] {
  <Iterative-Equality;
}

tpl [Single-Assumption] {
  <Single-Assumption {
    apply [*];
  }
}

tpl [Item[@kind='Assumption']] {
  <Item {
    @kind = "Assumption";
    apply [*];
  }
}

tpl [Iterative-Step] {
  <Iterative-Step {
    apply [*];
  }
}

tpl [Collective-Assumption] {
  <Collective-Assumption {
    apply [*];
  }
}

tpl [Item[@kind='Existential-Assumption']] {
  <Item {
    @kind = "Existential-Assumption";
    apply [*];
  }
}

tpl [Item[@kind='Conclusion']] {
  <Item {
    @kind = "Conclusion";
    apply [*];
  }
}

tpl [Item[@kind='Mode-Synonym']] {
  <Item {
    @kind = "Mode-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Func-Synonym']] {
  <Item {
    @kind = "Func-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Attr-Synonym']] {
  <Item {
    @kind = "Attr-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Pred-Synonym']] {
  <Item {
    @kind = "Pred-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Attr-Antonym']] {
  <Item {
    @kind = "Attr-Synonym";
    apply [*];
  }
}

tpl [Item[@kind='Pred-Antonym']] {
  <Item {
    @kind = "Pred-Antonym";
    apply [*];
  }
}

tpl [Block[@kind='Notation-Block']] {
  <Block {
    @kind = "Notation-Block";
    apply [*];
  }
}

tpl [Item[@kind='Theorem-Item']] {
  <Item {
    @kind="Theorem-Item";
    apply [*];
  }
}

tpl [Block[@kind='Now-Reasoning']] {
  <Block {
    @kind = "Now-Reasoning";
    apply [*];
  }
}

tpl [Block[@kind='Hereby-Reasoning']] {
  <Block {
    @kind = "Hereby-Reasoning";
    apply [*];
  }
}

tpl [Item[@kind='Type-Changing-Statement']] {
  <Item {
    @kind = "Type-Changing-Statement";
    apply [*];
  }
}

tpl [Equality] {
  <Equality {
    apply [*];
  }
}

tpl [Item[@kind='Regular-Statement']] {
  <Item {
    @kind = "Regular-Statement";
    apply [*];
  }
}

tpl [Universal-Quantifier-Formula] {
  <Universal-Quantifier-Formula {
    apply [*];
  }
}

tpl [Existential-Quantifier-Formula] {
  <Existential-Quantifier-Formula {
    apply [*];
  }
}

tpl [Schematic-Variables] {
  <Schematic-Variables {
    apply [*];
  }
}

tpl [Provisional-Formulas] {
  <Provisional-Formulas {
    apply [*];
  }
}

tpl [Item[@kind='Scheme-Head']] {
  <Item {
    @kind = "Scheme-Head";
    apply [*];
  }
}
