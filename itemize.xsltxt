stylesheet 1.0;

output method=xml indent="yes";

key "binder" [/Text-Proper/Item[@kind = "Reservation" or @kind = "Private-Predicate-Definition" or @kind = "Private-Functor-Definition" or @kind = "Constant-Definition" or @kind = "Type-Changing-Statement" or (@kind="Regular-Statement" and child::Diffuse-Statement)]] `@toplevel-binder-number`;

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl first-token (#token-string) {
  if [$token-string = ""] {
    die (#message = "We can't find the first token of an empty token string!");
  } else {
    if [starts-with ($token-string, ",")] {
      $after-first-comma = `substring-after ($token-string, ",")`;
      $between-first-and-second-comma = `substring-before ($after-first-comma, ",")`;
      if [$between-first-and-second-comma = ""] {
        $message = `concat ("We cannot compute the first token of the token string '", $token-string, "', because it starts with two adjacent commas")`;
        die (#message = $message);
      } else {
        `concat (",", $between-first-and-second-comma, ",")`;
      }
    } else {
      $message = `concat ("We cannot compute the first token of the token string '", $token-string, "; because it does not start with a comma and is thus not a valid token string")`;
      die (#message = $message);
    }
  }
}

tpl token-string-tail (#token-string) {
  if [$token-string = ""] {
    "";
  } else {
    if [starts-with ($token-string, ",")] {
      $after-first-comma = `substring-after ($token-string, ",")`;
      if [contains ($after-first-comma, ",")] {
        $after-second-comma = `substring-after ($after-first-comma, ",")`;
        if [$after-second-comma = ""] {
          "";
        } else {
          `concat (",", $after-second-comma)`;
        }
      } else {
        $message = `concat ("We cannot compute the tail of the token string '", $token-string, "', because it contains only one comma; valid token strings contain at least two commas")`;
        die (#message = $message);
      }
    } else {
      $message = `concat ("We canot take the tail of the token string '", $token-string, "': since it does not begin with a comma, it is not actually a valid token string")`;
      die (#message = $message);
    }
  }
}

tpl append-token-strings (#token-string-a, #token-string-b) {
  choose {
    when [$token-string-a = ""] { $token-string-b; }
    when [$token-string-b = ""] { $token-string-a; }
    otherwise {
      $b-minus-initial-comma = `substring-after ($token-string-b, ",")`;
      `concat ($token-string-a, $b-minus-initial-comma)`;
    }
  }
}

tpl value-of-token (#token) {
  if [starts-with ($token, ",")] {
    $after-first-comma = `substring-after ($token, ",")`;
    if [contains ($after-first-comma, ",")] {
      `substring-before ($after-first-comma, ",")`;
    } else {
      $message = `concat ("The token '", $token, "' does not contain two commas, so it is not actually a valid token")`;
      die (#message = $message);
    }
  } else {
    $message = `concat ("The token '", $token, "' does not start with a comma, so it is not actually a valid token")`;
    die (#message = $message);
  }
}

tpl ensure-reservations-have-numbers {
  for-each [//Item[@kind = "Reservation"]] {
    if [not(@toplevel-binder-number)] {
      die (#message = "This stylesheet assumes that all reservation items have a reservation-number attribute, but there is at least one in this document that lacks this attribute.");
    }
  }
}

tpl ensure-reservations-have-unique-numbers {
  for-each [//Item[@kind = "Reservation"]] {
    $reservation-number = `@toplevel-binder-number`;
    if [//Item[@kind = "Reservation" and @toplevel-binder-number = $reservation-number][2]] {
      die (#message = "This stylesheet assumes that each reservation item has a reservation number attribute shared by no other reservation item, but this document has has at least two reservation items sharing the same reservation number.");
    }
  }
}

tpl ensure-loci-declarations-bind-only-one-variable {
  for-each [//Item[@kind = "Loci-Declaration"]] {
    if [*/Variable[2]] {
      die (#message = "This stylesheet assumes that all loci declarations bind exactly one variable, but there is at least one loci delcaration in this document that binds multiple variables.");
    }
  }
}

tpl ensure-loci-have-numbers {
  for-each [//Item[@kind = "Loci-Declaration"]] {
    if [not(@loci-number)] {
      die (#message = "This stylesheet assumes that all loci declarations items have a loci-number attribute, but there is at least one loci declaration in this document that lacks this attribute.");
    }
  }
}

tpl [/] {
  ensure-reservations-have-numbers ();
  ensure-reservations-have-unique-numbers ();
  ensure-loci-declarations-bind-only-one-variable ();
  ensure-loci-have-numbers ();
  apply [*];
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl enumerate-items (#candidates, #bundlenr, #articleid) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    apply [$candidate](#bundlenr = $bundlenr, #articleid = $articleid);
    for-each [$candidate] {
      if [position() != last()] {
        "\n";
      }
    }
    enumerate-items (#candidates = `$candidates[position () > 1]`,
                     #bundlenr = `$bundlenr + 1`,
                     #articleid = $articleid);
  }
}

tpl [Text-Proper] {
  <Items {
    enumerate-items (#candidates = `Item[@kind != "Reservation" and @kind != "Private-Predicate-Definition" and @kind != "Private-Functor-Definition"]`,
                     #bundlenr = "1",
                     #articleid = `@articleid`);
  }
}

tpl reservation-binds-some-dependent-type-occuring-in-context (#reservation, #more-reservations, #context) {
  $reservation_variable = `$reservation/Variable[1]`;
  $reservation_idnr = `$reservation_variable/@idnr`;
  if [$more-reservations] {
    $another_reservation = `$more-reservations[1]`;
    if [$another_reservation//Simple-Term] {
      // the type occurring in $another_reservation is a dependent type.  Are any of the
      // terms bound by its dependent type bound by $reservation?
      if [$another_reservation//Simple-Term[@idnr = $reservation_idnr]] {
        $another_reservation_variable = `$another_reservation/Variable[1]`;
        $another_reservation_idnr = `$another_reservation_variable/@idnr`;
        // does the variable bound by $another_reservation occur anywhere inside $context?
        if [$context//@idnr = $another_reservation_idnr] {
          "1";
        } else {
          reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                     #more-reservations = `$more-reservations[position() > 1]`,
                                                                     #context = $context);
        }
      } else {
        reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                   #more-reservations = `$more-reservations[position() > 1]`,
                                                                   #context = $context);
      }
    } else {
      // the type occurring in $another_reservation is not a dependent type
      reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                 #more-reservations = `$more-reservations[position() > 1]`,
                                                                 #context = $context);
    }
  } else {
    "0";
  }
}

tpl some-term-occurs-in-context (#terms, #context) {
  if [$terms] {
    $term = `$terms[1]`;
    $term_idnr = `$term/@idnr`;
    if [$context//@idnr = $term_idnr] {
      "1";
    } else {
      some-term-occurs-in-context (#terms = `$terms[position() > 1]`,
                                   #context = $context);
    }
  } else {
    "0";
  }
}

tpl loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration, #more-loci, #context) {
  $loci_variable = `$loci-declaration/*/Variable[1]`;
  $loci_idnr = `$loci_variable/@idnr`;
  if [$more-loci] {
    $another_loci = `$more-loci[1]`;
    $another_loci_variable = `$another_loci/*/Variable[1]`;
    $another_loci_idnr = `$another_loci_variable/@idnr`;
    if [$another_loci//Simple-Term] {
      // the type occurring in $another_loci is a dependent type.  Are any of the
      // terms bound by its dependent type bound by $loci-declaration?
      if [$another_loci//Simple-Term[@idnr = $loci_idnr]] {
        // does the variable bound by $another_loci occur anywhere inside $context?
        if [$context//@idnr = $another_loci_idnr or $context//@nr = $another_loci_idnr] {
          "1";
        } else {
          loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration = $loci-declaration,
                                                                          #more-loci = `$more-loci[position() > 1]`,
                                                                          #context = $context);
        }
      } else {
        loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration = $loci-declaration,
                                                                        #more-loci = `$more-loci[position() > 1]`,
                                                                        #context = $context);
      }
    } else {
      if [preceding::Item[@kind = "Reservation"]/Variable[@idnr = $another_loci_idnr]] {
        $type = `preceding::Item[@kind = "Reservation"]/Variable[@idnr = $another_loci_idnr]/../*[position() = last()]`; // type
        $occurs = some-term-occurs-in-context (#terms = `$type//Simple-Term`, #context = $context);
        if [$occurs = "1"] {
          "1";
        } else {
          if [$type//Simple-Term/@idnr = $loci_idnr] {
            "1";
          } else {
            loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration = $loci-declaration,
                                                                            #more-loci = `$more-loci[position() > 1]`,
                                                                            #context = $context);
          }
        }
      } else {
        // the type occurring in $another_loci is not a dependent type
        loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration = $loci-declaration,
                                                                        #more-loci = `$more-loci[position() > 1]`,
                                                                        #context = $context);
      }
    }
  } else {
    "0";
  }
}

tpl index-of-reservation-with-maximal-number (#reservations) {
  if [$reservations] {
    if [$reservations[2]] {
      $reservation = `$reservations[1]`;
      $reservation_number = `$reservation/@toplevel-binder-number`;
      $index_for_tail = index-of-reservation-with-maximal-number (#reservations = `$reservations[position() > 1]`);
      $adjusted_index = `$index_for_tail + 1`;
      $best_in_tail = `$reservations[$adjusted_index]`;
      $best_in_tail_reservation_number = `$best_in_tail/@toplevel-binder-number`;
      if [$reservation_number > $best_in_tail_reservation_number] {
        "1";
      } else {
        $adjusted_index;
      }
    } else {
      "1";
    }
  } else {
    die (#message = "We cannot compute the index of something in an empty node set!");
  }
}

tpl index-of-reservation-with-minimal-number (#reservations) {
  if [$reservations] {
    if [$reservations[2]] {
      $reservation = `$reservations[1]`;
      $reservation_number = `$reservation/@toplevel-binder-number`;
      $index_for_tail = index-of-reservation-with-minimal-number (#reservations = `$reservations[position() > 1]`);
      $adjusted_index = `$index_for_tail + 1`;
      $best_in_tail = `$reservations[$adjusted_index]`;
      $best_in_tail_reservation_number = `$best_in_tail/@toplevel-binder-number`;
      if [$reservation_number < $best_in_tail_reservation_number] {
        "1";
      } else {
        $adjusted_index;
      }
    } else {
      "1";
    }
  } else {
    die (#message = "We cannot compute the index of something in an empty node set!");
  }
}

tpl index-of-loci-declaration-with-minimal-number (#loci) {
  if [$loci] {
    if [$loci[2]] {
      $locus = `$loci[1]`;
      $locus_number = `$locus/@loci-number`;
      $index_for_tail = index-of-loci-declaration-with-minimal-number (#loci = `$loci[position() > 1]`);
      $adjusted_index = `$index_for_tail + 1`;
      $best_in_tail = `$loci[$adjusted_index]`;
      $best_in_tail_loci_number = `$best_in_tail/@loci-number`;
      if [$locus_number < $best_in_tail_loci_number] {
        "1";
      } else {
        $adjusted_index;
      }
    } else {
      "1";
    }
  } else {
    die (#message = "We cannot compute the index of something in an empty node set!");
  }
}

// Determine whether there is a path from the variable bound by
// $reservation to $context (i.e., whether the variable occurs
// anywhere inside $context).  $later-reservations is a node set of
// reservation items that we may need to consult.  $already-handled is
// a token list of idnr's of variables that we have already dealt
// with.
//
// There is no path when the variable bound by $reservation occurs in
// $later-reservations (because the variable will be rebound later).
// If this condition fails, there is a path provided either:
//
// * the variable bound by $reservation occurs freely in $context, or
//
// * the variable bound by $reservation occurs in an implicitly
//   qualified segment in $context, or
//
// * the variable bound by $reservation occurs as a simple term in
//   some reservation R in $later-reservations, and there is a path
//   from R to the context.  (This is where recursive path search
//   enters.)

tpl exists-path-from-some-reservation-to-context (#reservations, #context, #later-reservations) {
  if [$reservations = ""] {
    "0";
  } else {
    $reservation-number-token = first-token (#token-string = $reservations);
    $reservation-number = value-of-token (#token = $reservation-number-token);
    $reservation = `key ("binder", $reservation-number)`;
    $exists-path = exists-path-from-reservation-to-context (#reservation = $reservation,
                                                            #context = $context,
                                                            #later-reservations = $later-reservations);
    if [$exists-path = "0"] {
      $reservations-tail = token-string-tail (#token-string = $reservations);
      exists-path-from-some-reservation-to-context (#reservations = $reservations-tail,
                                                    #context = $context,
                                                    #later-reservations = $later-reservations);
    } else {
      "1";
    }
  }
}

// Is the reservation-number attribute of $reservation bigger than the
// reservation-number attribute of every reservation in $reservations?
tpl reservation-follows-every-reservation (#reservation-number, #reservations) {
  if [$reservations = ""] {
    "1";
  } else {
    $potential-spoiler-token = first-token (#token-string = $reservations);
    $potential-spoiler-number = value-of-token (#token = $potential-spoiler-token);
    $potential-spoiler = `key ("binder", $potential-spoiler-number)`;
    $potential-spoiler-reservation-number = `$potential-spoiler/@toplevel-binder-number`;
    if [$potential-spoiler-reservation-number < $reservation-number] {
      reservation-follows-every-reservation (#reservation-number = $reservation-number,
                                             #reservations = `$reservations[position() > 1]`);
    } else {
      "0";
    }
  }
}

// Return the subset of $all-reservations consisting of those
// reservations whose reservation-number attribute is greater than
// every reservation in $reservation.
tpl reservations-following-every-helper (#reservations, #all-reservations, #val) {
  if [$all-reservations = ""] {
    $val;
  } else {
    $reservation-token = first-token (#token-string = $reservations);
    $reservation = value-of-token (#token = $reservation-token);
    $reservations-tail = token-string-tail (#token-string = $all-reservations);
    $bigger = reservation-follows-every-reservation (#reservation-number = $reservation,
                                                     #reservations = $reservations);
    if [$bigger = "0"] {
      reservations-following-every-helper (#reservations = $reservations,
                                           #all-reservations = $reservations-tail);
    } else {
      $new-value = append-token-strings (#token-string-a = $val,
                                         #token-string-b = $reservation-token);
      reservations-following-every-helper (#reservations = $reservations,
                                           #all-reservations = $reservations-tail,
                                           #val = $new-value);
    }
  }
}

tpl reservations-following-every (#reservations, #all-reservations) {
  reservations-following-every-helper (#reservations = $reservations,
                                       #all-reservations = $all-reservations,
                                       #val = "");
}

tpl idnr-occurs-in-dependent-type-of-some-reservation (#idnr, #reservations) {
  if [$reservations = ""] {
    "0";
  } else {
    $first-reservation-number-token = first-token (#token-string = $reservations);
    $first-reservation-number = value-of-token (#token = $first-reservation-number-token);
    $first-reservation = `key ("binder", $first-reservation-number)`;
    if [$first-reservation//Simple-Term[@idnr = $idnr]] {
      "1";
    } else {
      $remaining-reservations = token-string-tail (#token-string = $reservations);
      idnr-occurs-in-dependent-type-of-some-reservation (#idnr = $idnr,
                                                         #reservations = $remaining-reservations);
    }
  }
}

tpl dependent-type-reservations-in-which-idnr-occurs-helper (#idnr, #reservations, #val) {
  $idnr-token = `concat (",", $idnr, ",")`;
  if [$reservations = ""] {
    $val;
  } else {
    $first-reservation-number-token = first-token (#token-string = $reservations);
    $first-reservation-number = value-of-token (#token = $first-reservation-number-token);
    $first-reservation = `key ("binder", $first-reservation-number)`;
    $first-reservation-free-variables = `$first-reservation/@free-variables`;
    $reservations-tail = token-string-tail (#token-string = $reservations);
    if [contains ($first-reservation-free-variables, $idnr-token)] {
      $new-value = append-token-strings (#token-string-a = $val,
                                         #token-string-b = $first-reservation-number-token);
      dependent-type-reservations-in-which-idnr-occurs-helper (#idnr = $idnr,
                                                               #reservations = $reservations-tail,
                                                               #val = $new-value);
    } else {
      dependent-type-reservations-in-which-idnr-occurs-helper (#idnr = $idnr,
                                                               #reservations = $reservations-tail,
                                                               #val = $val);
    }
  }
}

tpl dependent-type-reservations-in-which-idnr-occurs (#idnr, #reservations) {
  dependent-type-reservations-in-which-idnr-occurs-helper (#idnr = $idnr,
                                                           #reservations = $reservations,
                                                           #val = "");  
}

// $reservations is a list of reservation numbers
tpl idnr-bound-by-some-reservation (#idnr, #reservations) {
  if [$reservations = ""] {
    "0";
  } else {
    $first-reservation-number-token = first-token (#token-string = $reservations);
    $first-reservation-number = value-of-token (#token = $first-reservation-number-token);
    $first-reservation = `key ("binder", $first-reservation-number)`;
    if [$first-reservation/@idnr = $idnr] {
      "1";
    } else {
      $remaining-reservations = token-string-tail (#token-string = $reservations);
      idnr-bound-by-some-reservation (#idnr = $idnr,
                                      #reservations = $remaining-reservations);
    }
  }
}

tpl exists-path-from-reservation-to-context (#reservation, #context, #later-reservations) {
  $idnr = `$reservation/@idnr`;
  $token = `concat (",", $idnr, ",")`;
  $bound-later = idnr-bound-by-some-reservation (#idnr = $idnr, #reservations = $later-reservations);
  if [$bound-later = "1"] {
    "0";
  } else {
    $free-variables-of-context = `$context/@free-variables`;
    $dependent-type-reservations-with-idnr = dependent-type-reservations-in-which-idnr-occurs (#idnr = $idnr,
                                                                                               #reservations = $later-reservations);
    choose {
      when [contains ($free-variables-of-context, $token)] { "1"; }
      when [$context//Implicitly-Qualified-Segment/Variable[@idnr = $idnr]] { "1"; }
      when [$dependent-type-reservations-with-idnr = ""] { "0"; }
      otherwise {
        $reservations-after-candidates = reservations-following-every (#reservations = $dependent-type-reservations-with-idnr,
                                                                       #all-reservations = $later-reservations);
        exists-path-from-some-reservation-to-context (#reservations = $dependent-type-reservations-with-idnr,
                                                      #context = $context,
                                                      #later-reservations = $reservations-after-candidates);
      }
    }
  }
}

tpl reservation-node-set-to-token-string (#reservations) {
  if [$reservations] {
    $reservation = `$reservations[1]`;
    $reservation-number = `$reservation/@toplevel-binder-number`;
    $token = `concat (",", $reservation-number, ",")`;
    $tail-token-string = reservation-node-set-to-token-string (#reservations = `$reservations[position() > 1]`);
    append-token-strings (#token-string-a = $token,
                          #token-string-b = $tail-token-string);
  } else {
    "";
  }
}

tpl needed-reservations (#reservations, #context) {
  if [$reservations] {
    $index_of_min = index-of-reservation-with-minimal-number (#reservations = $reservations);
    $reservation = `$reservations[position() = $index_of_min]`;
    $other-reservations = `$reservations[position() != $index_of_min]`;
    $other-reservations-as-token-string = reservation-node-set-to-token-string (#reservations = $other-reservations);
    $exists-path = exists-path-from-reservation-to-context (#reservation = $reservation,
                                                            #context = $context,
                                                            #later-reservations = $other-reservations-as-token-string);
    if [$exists-path = "1"] {
      copy-of `$reservation`;
    }
    needed-reservations (#reservations = $other-reservations,
                         #context = $context); 
  }
}

tpl [Text-Proper/Item](#bundlenr, #articleid) {
  <Item-Bundle {

    if [$bundlenr] {
      @bundlenr = $bundlenr;
    } else {
      die (#message = "Cannot process a top-level item without a bundle number");
    }

    if [$articleid] {
      @articleid = $articleid;
    } else {
      die (#message = "Cannot process a top-level item without an article id");
    }

    $context = `.`;

    <Text-Proper {
      needed-reservations (#reservations = `preceding::Item[@kind="Reservation"]`, #context = $context);
      copy {
        // possibly promote toplevel Regular-Statement items to theorems
        if [@kind = "Regular-Statement"] {
          if [Compact-Statement] {
            @kind = "Theorem-Item";
          } else {
            die (#message = "Don't know how to deal with non-Compact-Statement-type toplevel Regular-Statement items!");
          }
        } else {
          @kind = `@kind`;
        }
        @line = `@line`; @col = `@col`;
        apply [*];
      }
    }
  }
}

tpl [Item[@kind="Reservation"]] {
  if [Variable[2]] {
    die (#message = "We found a reservation that reserves more than one variable!");
  }
  if [not(@idnr)] {
    die (#message = "We found a reservation that lacks an idnr attribute!");
  }
}

// Resolving article-local references

tpl [Scheme-Justification[@nr = "0"]] {
  $context = `.`;
  if [@idnr and @spelling and @nr] {
    $idnr = `@idnr`;
    if [ancestor::Text-Proper/Item[@kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr = $idnr]] {
      $item = `ancestor::Text-Proper/Item[@kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr = $idnr]/../../..`; // wow
      if [$item] {
        for-each [$item] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $spelling = `concat ("CKB", $position)`;
          <Scheme-Justification {
            @spelling = $spelling;
	    @idnr = "1";
	    @nr = "1"; // might not be right
            @promoted = "promoted";
            apply [`$context/*`];
          }
        }
      } else {
        $message = `concat ("Something went wrong when finding the Item-Bundle that defines the article-local scheme ", @spelling)`;
        die (#message = $message);
      }
    } else {
      die (#message = "Unable to resolve a reference to an article-local scheme because we are unable to find a previous scheme under the same name");
    }
  } else {
    die (#message = "We found a Scheme-Justification that lacks either an idnr, spelling, or nr attribute!");
  }  
}

tpl [Local-Reference] {
  $context = `.`;
  if [@idnr and @line and @col and @spelling] {
    $idnr = `@idnr`;
    $line = `@line`;
    $col = `@col`;
    $spelling = `@spelling`;
    choose {
      // look for a previous unexported toplevel theorem (lemma)
      when [ancestor::Text-Proper/Item[@kind = "Regular-Statement"]/Proposition/Label[@idnr = $idnr]] {
        for-each [(ancestor::Text-Proper/Item[@kind = "Regular-Statement"]/Proposition/Label[@idnr = $idnr]/../..)[1]] { // the '[1]' is paranoia: watch out labels that apply to multiple theorems!  See SETFAM_1 in MML 4.166.1132
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $new_spelling = `concat ("CKB", $position)`;
          <Theorem-Reference {
            @spelling = $new_spelling;
            @promoted = "promoted";
            @"number" = "1";
          }
        }
      }
      // look for a previous exported toplevel theorem
      when [preceding::Item[@kind = "Theorem-Item"]/Proposition/Label[@idnr = $idnr]] {
        for-each [preceding::Item[@kind = "Theorem-Item"]/Proposition/Label[@idnr = $idnr]/../..] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $new_spelling = `concat ("CKB", $position)`;
          <Theorem-Reference {
            @spelling = $new_spelling;
            @promoted = "promoted";
            @"number" = "1";
          }
        }
      }
      // look for a previous non-mode definition
      when [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition"]/Definiens/Label[@idnr = $idnr]] {
        for-each [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition"]/Definiens/Label[@idnr = $idnr]/../../../..] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $new_spelling = `concat ("CKB", $position)`;
          <Definition-Reference {
            @spelling = $new_spelling;
            @promoted = "promoted";
            @"number" = "1";
          }
        }
      }
      // look for a previous mode definition
      when [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]] {
        for-each [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]/../../../../..] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $new_spelling = `concat ("CKB", $position)`;
          <Definition-Reference {
            @spelling = $new_spelling;
            @promoted = "promoted";
            @"number" = "1";
          }
        }
      }
      // don't know how to resolve; just copy this thing
      otherwise {
        <Local-Reference {
          @line = $line;
          @col = $col;
          @spelling = $spelling;
          @idnr = $idnr;
        }
      }
    }
  } else {
    die (#message = "We found a Local-Reference item that lacks an idnr attribute!");
  }
}

tpl needed-loci-helper (#loci, #context, #seen) {
  if [$loci] {
    $index_of_max = index-of-loci-declaration-with-minimal-number (#loci = $loci);
    $loci-declaration = `$loci[position() = $index_of_max]`;
    $other_loci = `$loci[position() != $index_of_max]`;
    $loci_number = `$loci-declaration/@loci-number`;
    $idnr = `$loci-declaration/@idnr`;
    $token = `concat (",", $idnr, ",")`;
    if [contains ($seen, $token)] {
      needed-loci-helper (#loci = $other_loci,
                          #context = $context,
                          #seen = $seen);
    } else {
      if [$other_loci/@idnr = $idnr] { // this variable will be bound by some later loci declaration; don't emit this earlier one
        needed-loci-helper (#loci = $other_loci,
                            #context = $context,
                            #seen = $seen);
      } else {
        $term_found = loci-declaration-binds-some-dependent-type-occuring-in-context (#loci-declaration = $loci-declaration,
                                                                                      #more-loci = $other_loci,
                                                                                      #context = $context);
        if [$term_found = "0"] {
          if [$context//Simple-Term[@idnr = $idnr] | $context//Locus[@nr = $idnr]] {
            copy-of `$loci-declaration`;
            needed-loci-helper (#loci = $other_loci,
                                #context = $context,
                                #seen = `concat ($seen, $token)`);
          } else {
            needed-loci-helper (#loci = $other_loci,
                                #context = $context,
                                #seen = $seen);
          }
        } else {
          copy-of `$loci-declaration`;
          needed-loci-helper (#loci = $other_loci,
                              #context = $context,
                              #seen = `concat ($seen, $token)`);
        }
      }
    }
  }
}

tpl needed-loci (#loci, #context) {
  needed-loci-helper (#loci = $loci,
                      #context = $context,
                      #seen = "");
}

tpl [Block[@kind = "Definitional-Block"]] {
  <Block {
    for-each [@*] { copy-of `.`; }
    apply [Item[@kind = "Functor-Definition" or @kind = "Predicate-Definition" or @kind = "Attribute-Definition" or @kind = "Mode-Definition"]];
    apply [Item[@kind = "Correctness" or @kind = "Correctness-Condition" or @kind = "Property"]];
  }
}

tpl [Item[@kind = "Functor-Definition" or @kind = "Predicate-Definition" or @kind = "Attribute-Definition" or @kind = "Mode-Definition"]] {
  needed-loci (#loci = `preceding-sibling::Item[@kind="Loci-Declaration"]`, #context = `*`);
  apply [preceding-sibling::Item[@kind = "Assumption" or @kind = "Existential-Assumption"]];
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Block[@kind = "Registration-Block"]] {
  <Block {
    for-each [@*] { copy-of `.`; }
    apply [Item[@kind = "Cluster"]];
    apply [Item[@kind = "Correctness" or @kind = "Correctness-Condition"]];
  }
}

tpl [Item[@kind = "Cluster"]] {
  needed-loci (#loci = `preceding-sibling::Item[@kind="Loci-Declaration"]`, #context = `.`);
  <Item {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}