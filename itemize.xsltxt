stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

// Assumes that the context node is a Variable
tpl apply-type-of-variable(#spelling) {
  if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
    if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type] {
      apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type[1]];
    } else {
      $message = `concat ("Unable to determine the type of an implicitly qualified variable, ", $spelling, ", bound by a reservation")`;
      die (#message = $message);
    }
  } else {
    if [preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]] {
      if [preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Standard-Type | preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Clustered-Type] {
        apply [(preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Standard-Type | preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Clustered-Type)[1]];
      } else {
        $message = `concat ("Unable to determine the type of an implicitly qualified variable, ", $spelling, ", introduced by a type-changing statement")`;
        die (#message = $message);
      }
    } else {
      $message = `concat ("Could not determine type of an implicitly qualified variable, ", $spelling, ": it is not bound by a resevation, nor introduced by a type-changing statement!")`;
      die (#message = $message);
    }
  }
}

tpl [Implicitly-Qualified-Segment] {
  <Explicitly-Qualified-Segment {
    for-each [Variable] {
      $spelling = `@spelling`;
      apply [.];
      apply-type-of-variable (#spelling = $spelling);
    }
  }
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    if [@spelling] { @spelling = `@spelling`; }
    if [@idnr] { @idnr = `@idnr`; }
    if [@nr] { @nr = `@nr`; }
    if [@number] { @"number" = `@number`; }
    if [@articleid] { @articleid = `@articleid`; }
    if [@kind] { @kind = `@kind`; }
    apply [*];
  }
}

tpl enumerate-items (#candidates, #bundlenr, #articleid) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    apply [$candidate](#bundlenr = $bundlenr, #articleid = $articleid);
    for-each [$candidate] {
      if [position() != last()] {
        "\n";
      }
    }
    enumerate-items (#candidates = `$candidates[position () > 1]`,
                     #bundlenr = `$bundlenr + 1`,
                     #articleid = $articleid);
  }
}

tpl [Text-Proper] {
  <Items {
    enumerate-items (#candidates = `Item[@kind != "Reservation"]`,
                     #bundlenr = "1",
                     #articleid = `@articleid`);
  }
}

tpl emit-needed-reservations-helper(#candidates, #seen) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = `$candidate/@spelling`;
    $line = `$candidate/@line`;
    $col = `$candidate/@col`;
    $var_token = `concat ($spelling, ",")`;
    if [contains ($seen, $var_token)] {
      emit-needed-reservations-helper(#candidates = `$candidates[position() > 1]`,
                                      #seen = $seen);
    } else {
      if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
        for-each [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling][1]] {
          copy { @spelling = `@spelling`; @line = `@line`; @col = `@col`; }
        }
        if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type] {
          for-each [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type[1]] {
            copy { @spelling = `@spelling`; @line = `@line`; @col = `@col`; }
          }
        } else {
          $message = `concat ("Unable to determine the type of the variable ", $spelling, " occuring at line ", $line, " and column ", $col)`;
          die (#message = $message);
        }
      } else {
        $message = `concat ("Unable to find a registration for the variable ", $spelling, " occuring at line ", $line, " and column ", $col)`;
        die (#message = $message);
      }
    }
  }
}

// Assumes the context node is a formula of some kind
tpl emit-needed-reservations {
  emit-needed-reservations-helper(#candidates = `.//Implicitly-Qualified-Segment/Variable`,
                    #seen = "");
}

tpl [Text-Proper/Item](#bundlenr, #articleid) {
  <Item-Bundle {

    if [$bundlenr] {
      @bundlenr = $bundlenr;
    } else {
      die (#message = "Cannot process a top-level item without a bundle number");
    }

    if [$articleid] {
      @articleid = $articleid;
    } else {
      die (#message = "Cannot process a top-level item without an article id");
    }

    <Text-Proper {

      if [.//Implicitly-Qualified-Segment] {
        <Item {
          @kind = "Reservation";
          emit-needed-reservations ();
        }
      }
      copy {
        @kind = `@kind`; @line = `@line`; @col = `@col`;
        apply [*];
      }
    }
  }
}

tpl [Text-Proper/Item[@kind='Reservation']] {
  // do nothing
}