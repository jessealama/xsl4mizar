stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    if [@spelling] { @spelling = `@spelling`; }
    if [@idnr] { @idnr = `@idnr`; }
    if [@nr] { @nr = `@nr`; }
    if [@number] { @"number" = `@number`; }
    if [@articleid] { @articleid = `@articleid`; }
    if [@kind] { @kind = `@kind`; }
    apply [*];
  }
}

tpl enumerate-items (#candidates, #bundlenr, #articleid) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    apply [$candidate](#bundlenr = $bundlenr, #articleid = $articleid);
    for-each [$candidate] {
      if [position() != last()] {
        "\n";
      }
    }
    enumerate-items (#candidates = `$candidates[position () > 1]`,
                     #bundlenr = `$bundlenr + 1`,
                     #articleid = $articleid);
  }
}

tpl [Text-Proper] {
  <Items {
    enumerate-items (#candidates = `Item[@kind != "Reservation"]`,
                     #bundlenr = "1",
                     #articleid = `@articleid`);
  }
}

tpl reservation-binds-some-dependent-type-occuring-in-context (#reservation, #more-reservations, #context) {
  $reservation_variable = `$reservation/Variable[1]`;
  $reservation_idnr = `$reservation_variable/@idnr`;
  if [$more-reservations] {
    $another_reservation = `$more-reservations[1]`;
    if [$another_reservation//Simple-Term] {
      // the type occurring in $another_reservation is a dependent type.  Are any of the
      // terms bound by its dependent type bound by $reservation?
      if [$another_reservation//Simple-Term[@idnr = $reservation_idnr]] {
        $another_reservation_variable = `$another_reservation/Variable[1]`;
        $another_reservation_idnr = `$another_reservation_variable/@idnr`;
        // does the variable bound by $another_reservation occur anywhere inside $context?
        if [$context//@idnr = $another_reservation_idnr] {
          "1";
        } else {
          reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                     #more-reservations = `$more-reservations[position() > 1]`,
                                                                     #context = $context);
        }
      } else {
        reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                   #more-reservations = `$more-reservations[position() > 1]`,
                                                                   #context = $context);
      }
    } else {
      // the type occurring in $another_reservation is not a dependent type
      reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                 #more-reservations = `$more-reservations[position() > 1]`,
                                                                 #context = $context);
    }
  } else {
    "0";
  }
}

tpl index-of-reservation-with-maximal-number (#reservations) {
  if [$reservations] {
    if [$reservations[2]] {
      $reservation = `$reservations[1]`;
      $reservation_number = `$reservation/@reservation-number`;
      $index_for_tail = index-of-reservation-with-maximal-number (#reservations = `$reservations[position() > 1]`);
      $adjusted_index = `$index_for_tail + 1`;
      $best_in_tail = `$reservations[$adjusted_index]`;
      $best_in_tail_reservation_number = `$best_in_tail/@reservation-number`;
      if [$reservation_number > $best_in_tail_reservation_number] {
        "1";
      } else {
        $adjusted_index;
      }
    } else {
      "1";
    }
  } else {
    die (#message = "We cannot compute the index of something in an empty node set!");
  }
}

tpl index-of-reservation-with-minimal-number (#reservations) {
  if [$reservations] {
    if [$reservations[2]] {
      $reservation = `$reservations[1]`;
      $reservation_number = `$reservation/@reservation-number`;
      $index_for_tail = index-of-reservation-with-maximal-number (#reservations = `$reservations[position() > 1]`);
      $adjusted_index = `$index_for_tail + 1`;
      $best_in_tail = `$reservations[$adjusted_index]`;
      $best_in_tail_reservation_number = `$best_in_tail/@reservation-number`;
      if [$reservation_number < $best_in_tail_reservation_number] {
        "1";
      } else {
        $adjusted_index;
      }
    } else {
      "1";
    }
  } else {
    die (#message = "We cannot compute the index of something in an empty node set!");
  }
}

tpl needed-reservations-helper(#reservations, #context, #seen) {
  if [$reservations] {
    $index_of_max = index-of-reservation-with-minimal-number (#reservations = $reservations);
    $reservation = `$reservations[position() = $index_of_max]`;
    $res_number = `$reservation/@reservation-number`;
    $idnr = `$reservation/@idnr`;
    $token = `concat (",", $idnr, ",")`;
    if [contains ($seen, $token)] {
      needed-reservations-helper (#reservations = `$reservations[position() != $index_of_max]`,
                                  #context = $context,
                                  #seen = $seen);
    } else {
      if [$context//Simple-Term[@idnr = $idnr] | $context//Implicitly-Qualified-Segment/Variable[@idnr = $idnr]] {
        copy-of `$reservation`;
        needed-reservations-helper (#reservations = `$reservations[position() != $index_of_max]`,
                                    #context = $context,
                                    #seen = `concat ($seen, $token)`);
      } else {
        $term_found = reservation-binds-some-dependent-type-occuring-in-context (#reservation = $reservation,
                                                                                 #more-reservations = `$reservations[position() != $index_of_max]`,
                                                                                 #context = $context);
        if [$term_found = "0"] {
          needed-reservations-helper (#reservations = `$reservations[position() != $index_of_max]`,
                                      #context = $context,
                                      #seen = $seen);
        } else {
          copy-of `$reservation`;
          needed-reservations-helper (#reservations = `$reservations[position() != $index_of_max]`,
                                      #context = $context,
                                      #seen = `concat ($seen, $token)`);
        }
      }
    }
  }
}

tpl needed-reservations(#reservations, #context) {
  needed-reservations-helper (#reservations = $reservations,
                             #context = $context,
                             #seen = "");
}

tpl [Text-Proper/Item](#bundlenr, #articleid) {
  <Item-Bundle {

    if [$bundlenr] {
      @bundlenr = $bundlenr;
    } else {
      die (#message = "Cannot process a top-level item without a bundle number");
    }

    if [$articleid] {
      @articleid = $articleid;
    } else {
      die (#message = "Cannot process a top-level item without an article id");
    }

    $context = `.`;

    <Text-Proper {
      needed-reservations (#reservations = `preceding::Item[@kind="Reservation"]`, #context = $context);
      copy {
        if [@kind = "Regular-Statement"] {
          @kind = "Theorem-Item";
        } else {
          @kind = `@kind`;
        }
        @line = `@line`; @col = `@col`;
        apply [*];
      }
    }
  }
}

tpl [Text-Proper/Item[@kind="Reservation"]] {
  if [Variable[2]] {
    die (#message = "We found a reservation that reserves more than one variable!");
  }
  if [not(@idnr)] {
    die (#message = "We found a reservation that lacks an idnr attribute!");
  }
}

// Resolving article-local references

tpl [Scheme-Justification[@nr = "0"]] {
  $context = `.`;
  if [@idnr and @spelling and @nr] {
    $idnr = `@idnr`;
    if [ancestor::Text-Proper/Item[@kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr = $idnr]] {
      $item = `ancestor::Text-Proper/Item[@kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr = $idnr]/../../..`; // wow
      if [$item] {
        for-each [$item] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $spelling = `concat ("CKB", $position)`;
          <Scheme-Justification {
            @spelling = $spelling;
	    @idnr = "1";
	    @nr = "1"; // might not be right
            @promoted = "promoted";
            apply [`$context/*`];
          }
        }
      } else {
        $message = `concat ("Something went wrong when finding the Item-Bundle that defines the article-local scheme ", @spelling)`;
        die (#message = $message);
      }
    } else {
      die (#message = "Unable to resolve a reference to an article-local scheme because we are unable to find a previous scheme under the same name");
    }
  } else {
    die (#message = "We found a Scheme-Justification that lacks either an idnr, spelling, or nr attribute!");
  }  
}

tpl [Local-Reference] {
  $context = `.`;
  if [@idnr and @line and @col and @spelling] {
    $idnr = `@idnr`;
    $line = `@line`;
    $col = `@col`;
    $spelling = `@spelling`;
    // look for a previous unexported toplevel theorem (lemma)
    if [ancestor::Text-Proper/Item[@kind = "Regular-Statement"]/Proposition/Label[@idnr = $idnr]] {
      $item = `ancestor::Text-Proper/Item[@kind = "Regular-Statement"]/Proposition/Label[@idnr = $idnr]/../..`; // wow
      if [$item] {
        for-each [$item] {
          $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
          $new_spelling = `concat ("CKB", $position)`;
          <Theorem-Reference {
            @spelling = $new_spelling;
            @promoted = "promoted";
            @"number" = "1";
            apply [`$context/*`];
          }
        }
      } else {
        $message = `concat ("Something went wrong when finding the Item of kind Regular-Statement that defines the article-local reference ", @spelling)`;
        die (#message = $message);
      }
    } else {
      // look for a previous exported theorem
      if [ancestor::Text-Proper/Item[@kind = "Theorem-Item"]/Proposition/Label[@idnr = $idnr]] {
        $item = `ancestor::Text-Proper/Item[@kind = "Theorem-Item"]/Proposition/Label[@idnr = $idnr]/../..`; // wow
        if [$item] {
          for-each [$item] {
            $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
            $new_spelling = `concat ("CKB", $position)`;
            <Theorem-Reference {
              @spelling = $new_spelling;
              @promoted = "promoted";
              @"number" = "1";
              apply [`$context/*`];
            }
          }
        } else {
          $message = `concat ("Something went wrong when finding the Item of kind Theorem-Item that defines the article-local reference ", @spelling)`;
          die (#message = $message);
        }
      } else {
        // look for a previous definition
        if [ancestor::Text-Proper/Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition"]/Definiens/Label[@idnr = $idnr]] {
          $item = `ancestor::Text-Proper/Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition" or @kind = "Attribute-Definition" or @kind = "Predicate-Definition"]/Definiens/Label[@idnr = $idnr]/../../../..`; // wow
          if [$item] {
            for-each [$item] {
              $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
              $new_spelling = `concat ("CKB", $position)`;
              <Definition-Reference {
                @spelling = $new_spelling;
                @promoted = "promoted";
                @"number" = "1";
                apply [`$context/*`];
              }
            }
          } else {
            $message = `concat ("Something went wrong when finding the Item of kind Definition-Item that defines the article-local reference ", @spelling)`;
            die (#message = $message);
          }
        } else {
          if [ancestor::Text-Proper/Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]] {
            for-each [ancestor::Text-Proper/Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]/../../../../..] {
              $position = `count (preceding-sibling::*[not(@kind = "Reservation")]) + 1`;
              $new_spelling = `concat ("CKB", $position)`;
              <Definition-Reference {
                @spelling = $new_spelling;
                @promoted = "promoted";
                @"number" = "1";
                apply [`$context/*`];
              }
            }
          } else {
            <Local-Reference {
              @line = $line;
              @col = $col;
              @spelling = $spelling;
              @idnr = $idnr;
              apply [*];
            }
          }
        }
      }
    }
  } else {
    die (#message = "We found a Local-Reference item that lacks an idnr attribute!");
  }
}