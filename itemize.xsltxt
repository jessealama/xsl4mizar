stylesheet 1.0;

output method=xml indent="yes";

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [*] {
  $element = `local-name ()`;
  <$element {
    if [@line] { @line = `@line`; }
    if [@col] { @col = `@col`; }
    if [@spelling] { @spelling = `@spelling`; }
    if [@idnr] { @idnr = `@idnr`; }
    if [@nr] { @nr = `@nr`; }
    if [@number] { @"number" = `@number`; }
    if [@articleid] { @articleid = `@articleid`; }
    apply [*];
  }
}

tpl enumerate-items (#candidates, #bundlenr) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    apply [$candidate](#bundlenr = $bundlenr);
    enumerate-items (#candidates = `$candidates[position () > 1]`,
                     #bundlenr = `$bundlenr + 1`);
  }
}

tpl [Text-Proper] {
  <Text-Proper {
    @articleid = `@articleid`;
    @articleext = `@articleext`;
    @line = `@line`;
    @col = `@col`;
    enumerate-items (#candidates = `Item[@kind != "Reservation"]`,
                     #bundlenr = "1");
  }
}

tpl [Item[@kind='Reservation']] {
  // do nothing: We will manage variable reservations ourselves
}

tpl free-in-proposition-helper (#free_vars, #candidates) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = `$candidate/@spelling`;
    $var_token = `concat ($spelling, ",")`;
    $free = occurs-freely (#variable = $candidate);
    if [$free = "0"] {
      free-in-proposition-helper (#free_vars = $free_vars,
                                  #candidates = `$candidates[position() > 1]`);
    } else {
      if [contains ($free_vars, $var_token)] {
        free-in-proposition-helper (#free_vars = $free_vars,
                                    #candidates = `$candidates[position() > 1]`);
      } else {
        $new_free_vars = `concat ($free_vars, $var_token)`;
        free-in-proposition-helper (#free_vars = $new_free_vars,
                                    #candidates = `$candidates[position() > 1]`);
      }
    }
  } else {
    `$free_vars`;
  }
}

tpl free-in-proposition(#prop_node) {
  if [$prop_node] {
    free-in-proposition-helper (#free_vars = "",
                                #candidates = `$prop_node//Simple-Term`);
  } else {
    "";
  }
}

tpl [Block[@kind='Proof']](#already_bound) {
  <Block {
    @kind = "Proof";
    $free_in_proposition = free-in-proposition (#prop_node = `preceding-sibling::Proposition[1]`);
    $now_already_bound = `concat ($already_bound, $free_in_proposition)`;
    generalize-proof (#already_bound = $already_bound);
    apply [*](#already_bound = $now_already_bound, #do_generalize = "1");
  }
}

tpl [Definiens] {
  <Definiens {
    apply [*](#already_bound = "", #do_generalize = "1"); // is that OK?
  }
}

tpl apply-type-of-variable(#spelling) {
  if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
    if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type] {
      apply [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type[1]];
    } else {
      $message = `concat ("Unable to determine the type of an implicitly qualified variable, ", $spelling, ", bound by a reservation")`;
      die (#message = $message);
    }
  } else {
    if [preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]] {
      if [preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Standard-Type | preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Clustered-Type] {
        apply [(preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Standard-Type | preceding::Item[@kind="Type-Changing-Statement"]/Equality/Variable[@spelling = $spelling]/../../Clustered-Type)[1]];
      } else {
        $message = `concat ("Unable to determine the type of an implicitly qualified variable, ", $spelling, ", introduced by a type-changing statement")`;
        die (#message = $message);
      }
    } else {
      $message = `concat ("Could not determine type of an implicitly qualified variable, ", $spelling, ": it is not bound by a resevation, nor introduced by a type-changing statement!")`;
      die (#message = $message);
    }
  }
}

// Formulas

// Generalizing free variables

tpl generalize-helper(#candidates, #seen, #already_bound) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = $candidate/@spelling;
    $free = occurs-freely (#variable = $candidate);
    if [$free = "0"] {
      generalize-helper(#candidates = `$candidates[position() > 1]`,
                        #seen = $seen,
                        #already_bound = $already_bound);
    } else {
      $var_token = `concat ($spelling, ",")`;
      if [contains ($seen, $var_token)] {
        generalize-helper(#candidates = `$candidates[position() > 1]`,
                          #seen = $seen,
                          #already_bound = $already_bound);
      } else {
        if [contains ($already_bound, $var_token)] {
          generalize-helper (#candidates = `$candidates[position() > 1]`,
                             #seen = $seen,
                             #already_bound = $already_bound);
        } else {
          <Universal-Quantifier-Formula {
            <Explicitly-Qualified-Segment {
              <Variable {
                @spelling = $spelling;
                @elicited = "elicited";
              }
              apply-type-of-variable (#spelling = $spelling);
            }
            generalize-helper(#candidates = `$candidates[position() > 1]`,
                              #seen = `concat ($seen, $spelling, ",")`,
                              #already_bound = $already_bound);
          }
        }
      }
    }
  } else {
    $newly_bound = `concat ($seen, $already_bound)`;
    apply [.](#already_bound = $newly_bound, #do_generalize = "0");
  }
}

// Assumes the context node is a formula of some kind
tpl generalize(#already_bound) {
  generalize-helper(#candidates = `.//Simple-Term`,
                    #seen = "",
                    #already_bound = $already_bound);
}

// Assumes that the context node is a proof block
tpl generalize-proof-helper(#candidates, #seen, #already_bound) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = $candidate/@spelling;
    $free = occurs-freely (#variable = $candidate); 
    if [$free = "0"] {
      generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                              #seen = $seen,
                              #already_bound = $already_bound);
    } else {
      $var_token = `concat ($spelling, ",")`;
      if [contains ($seen, $var_token)] {
        generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                                #seen = $seen,
                                #already_bound = $already_bound);
      } else {
        if [contains ($already_bound, $var_token)] {
          generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                                  #seen = $seen,
                                  #already_bound = $already_bound);
        } else {
          <Item {
            @kind = "Loci-Declaration";        
            <Explicitly-Qualified-Segment {
              <Variable {
                @spelling = $spelling;
                @elicited = "elicited";
              }
              apply-type-of-variable (#spelling = $spelling);
            }
          }
          generalize-proof-helper(#candidates = `$candidates[position() > 1]`,
                                  #seen = `concat ($seen, $spelling, ",")`,
                                  #already_bound = `concat ($already_bound, $var_token)`);
          }
        }
      }
    }
  }


tpl generalize-proof(#already_bound) {
  generalize-proof-helper(#candidates = `../Proposition//Simple-Term`,
                          #seen = "",
                          #already_bound = $already_bound);
}

// Atoms

tpl [Attributive-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Attributive-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl [Predicative-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Predicative-Formula {
      @spelling=`@spelling`;
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl [Private-Predicate-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Private-Predicate-Formula {
      @spelling = `@spelling`;
      apply [*](#already_bound = $already_bound);
    }
  }
}

// Complex formulas

tpl [Conjunctive-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Conjunctive-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl [Disjunctive-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Disjunctive-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl [Conditional-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Conditional-Formula {
      apply [*](#already_bound);
    }
  }
}

tpl [Biconditional-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Biconditional-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

// Quantifed formulas

tpl [Universal-Quantifier-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Universal-Quantifier-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl [Existential-Quantifier-Formula](#already_bound, #do_generalize) {
  if [$do_generalize = "1"] {
    generalize (#already_bound = $already_bound);
  } else {
    <Existential-Quantifier-Formula {
      apply [*](#already_bound = $already_bound);
    }
  }
}

tpl bound-by-quantifier (#variable) {
  $spelling = `local-name ($variable/@spelling)`;
  for-each [$variable[1]] {
    if [ancestor::Universal-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
      "1";
    } else {
      if [ancestor::Universal-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
        "1";
      } else {
        if [ancestor::Existential-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
          "1";
        } else {
          if [ancestor::Existential-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
            "1";
          } else {
            "0";
          }
        }
      }
    }
  }
}

tpl bound-by-item-in-block (#variable, #block, #item) {
  $spelling = `$variable/@spelling`;
  if [$item[@kind = "Choice-Statement"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling] | $item[@kind = "Choice-Statement"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
    "1";
  } else {
    if [$item[@kind = "Generalization"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling] | $item[@kind = "Generalization"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
      "1";
    } else {
      if [$item[@kind = "Loci-Declaration"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling] | $item[@kind = "Loci-Declaration"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
        "1";
      } else {
        if [$item[@kind = "Existential-Assumption"]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling] | $item[@kind = "Existential-Assumption"]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
          "1";
        } else {
          "0";
        }
      }
    }
  }
}

// tpl item-containing-variable (#variable, #candidates) {
//   if [$candidates] {
//     $candidate = `$candidates[1]`;
//     if [$candidate//Simple-Term = $variable] {
//       $candidate;
//     } else {
//       item-containing-variable (#variable = $variable,
//                                 #candidates = `$candidates[position() > 1]`);
//     }
//   } else {
//     $spelling = `$variable/@spelling`;
//     $message = `concat ("We expected to find one (and only one) Item element that contains the variable ", $spelling, ", but none was found")`;
//     die (#message = $message);
//   }
// }

// tpl bound-in-block (#variable, #block) {
//   $item = item-containing-variable (#variable = $variable,
//                                     #candidates = `$block/Item`);
//   $item_pos = position ($item);
//   bound-by-item-in-block (#variable = $variable,
//                           #block = $block,
//                           #items = `Block/Item[position <= $item_pos]`);
// }

// tpl bound-in-blocks (#variable, #blocks) {
//   if [$blocks] {
//     $block = $blocks[1];
//     $bound = bound-in-block (#variable = $variable, #block = $block);
//     if [$bound = "0"] {
//       bound-in-blocks (#variable = $variable,
//                        #blocks = $blocks[position() > 1]);
//     } else {
//       "1";
//     }
//   } else {
//     "0";
//   }
// }

// tpl block-bound (#variable) {
//   bound-in-blocks (#variable = $variable, #blocks = `ancestor::Block`);
// }

tpl occurs-freely(#variable, #val) {
  if [$val] {
    $val;
  } else {
    $spelling = $variable/@spelling;
    $depth = `count (ancestor::*)`;
    for-each [$variable] { // kludge to force $variable to be the context node
      if [ancestor::Universal-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
        occurs-freely (#val = "0");
      } else {
        if [ancestor::Universal-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
          occurs-freely (#val = "0");
        } else {
          if [ancestor::Existential-Quantifier-Formula/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
            occurs-freely (#val = "0");
          } else {
            if [ancestor::Existential-Quantifier-Formula/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
              occurs-freely (#val = "0");
            } else {
              if [ancestor::Block/Item[@kind="Constant-Definition" and count(ancestor::*) < $depth]/Variable[@spelling = $spelling]] {
                occurs-freely (#val = "0");
              } else {
                if [ancestor::Block/Item[@kind="Choice-Statement" and count(ancestor::*) < $depth]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                  occurs-freely (#val = "0");
                } else {
                  if [ancestor::Block/Item[@kind="Choice-Statement" and count(ancestor::*) < $depth]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                    occurs-freely (#val = "0");
                  } else {
                    if [ancestor::Block/Item[@kind="Generalization" and count(ancestor::*) < $depth]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                      occurs-freely (#val = "0");
                    } else {
                      if [(ancestor::Block/Item[@kind="Generalization" and count(ancestor::*) < $depth]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling])] {
                        occurs-freely (#val = "0");
                      } else {
                        if [ancestor::Block/Item[@kind="Loci-Declaration" and count(ancestor::*) < $depth]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                          occurs-freely (#val = "0");
                        } else {
                          if [ancestor::Block/Item[@kind="Loci-Declaration" and count(ancestor::*) < $depth]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                            occurs-freely (#val = "0");
                          } else {
                            if [ancestor::Block/Item[@kind="Existential-Assumption" and count(ancestor::*) < $depth]/Explicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                              occurs-freely (#val = "0");
                            } else {
                              if [ancestor::Block/Item[@kind="Existential-Assumption" and count(ancestor::*) < $depth]/Implicitly-Qualified-Segment/Variable[@spelling = $spelling]] {
                                occurs-freely (#val = "0");
                              } else {
                                occurs-freely (#val = "1");
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}

tpl [Proposition](#already_bound) {
  <Proposition {
    apply [*](#already_bound = $already_bound, #do_generalize = "1");
  }
}

tpl [Item[@kind='Choice-Statement']](#already_bound) {
  <Item {
    @kind="Choice-Statement";
    apply [*](#already_bound = $already_bound);
  }
}

tpl [Single-Assumption](#already_bound) {
  <Single-Assumption {
    apply [*](#already_bound = $already_bound);
  }
}

tpl [Item[@kind='Assumption']](#already_bound) {
  <Item {
    @kind = "Assumption";
    apply [*](#already_bound = $already_bound);
  }
}

tpl [Collective-Assumption](#already_bound) {
  <Collective-Assumption {
    apply [*](#already_bound = $already_bound);
  }
}

tpl [Item[@kind='Existential-Assumption']](#already_bound) {
  <Item {
    @kind = "Existential-Assumption";
    apply [*](#already_bound = $already_bound, #do_generalize = "1");
  }
}

tpl [Item[@kind='Conclusion']](#already_bound) {
  <Item {
    @kind = "Conclusion";
    apply [*](#already_bound = $already_bound, #do_generalize = "1");
  }
}

tpl [Block[@kind='Now-Reasoning']](#already_bound) {
  <Block {
    @kind = "Now-Reasoning";
    apply [*](#already_bound = $already_bound, #do_generalize = "1");
  }
}

tpl [Block[@kind='Hereby-Reasoning']](#already_bound) {
  <Block {
    @kind = "Hereby-Reasoning";
    apply [*](#already_bound = $already_bound, #do_generalize = "1");
  }
}

tpl [Item[@kind='Regular-Statement']](#already_bound) {
  $parent_name = `local-name (parent::*)`;
  if [$parent_name = "Text-Proper"] {
    <Item {
      @kind = "Regular-Statement";
      apply [*[1]]; // should be Compact-Statement, Diffuse-Statement, or Iterative-Equality
      apply [Proposition[1]](#already_bound = $already_bound);
      if [Straightforward-Justification | Scheme-Justification] {
        apply [(Straightforward-Justification | Scheme-Justification)[1]];
      } else {
        if [Block[@kind='Proof']] {
          apply [Block[@kind='Proof'][1]];
        } else {
          die (#message = "Don't know how to deal with a Regular-Statement item that lacks a Straightforward-Justification, a Scheme-Justification, and a Proof block");
        }
      }
    }
  } else {
    <Item {
      @kind = "Regular-Statement";
      apply [*](#already_bound = $already_bound);
    }
  }
}



tpl emit-needed-reservations-helper(#candidates, #seen) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $spelling = `$candidate/@spelling`;
    $line = `$candidate/@line`;
    $col = `$candidate/@col`;
    $var_token = `concat ($spelling, ",")`;
    if [contains ($seen, $var_token)] {
      emit-needed-reservations-helper(#candidates = `$candidates[position() > 1]`,
                                      #seen = $seen);
    } else {
      if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]] {
        for-each [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling][1]] {
          copy { @spelling = `@spelling`; @line = `@line`; @col = `@col`; }
        }
        if [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type] {
          for-each [preceding::Item[@kind="Reservation"]/Variable[@spelling = $spelling]/../Standard-Type[1]] {
            copy { @spelling = `@spelling`; @line = `@line`; @col = `@col`; }
          }
        } else {
          $message = `concat ("Unable to determine the type of the variable ", $spelling, " occuring at line ", $line, " and column ", $col)`;
          die (#message = $message);
        }
      } else {
        $message = `concat ("Unable to find a registration for the variable ", $spelling, " occuring at line ", $line, " and column ", $col)`;
        die (#message = $message);
      }
    }
  }
}

// Assumes the context node is a formula of some kind
tpl emit-needed-reservations {
  emit-needed-reservations-helper(#candidates = `.//Implicitly-Qualified-Segment/Variable`,
                    #seen = "");
}

tpl [Text-Proper/Item](#bundlenr) {
  <Item-Bundle {

    if [$bundlenr] {
      @bundlenr = $bundlenr;
    } else {
      die (#message = "Cannot process a top-level item without a bundle number");
    }

    if [.//Implicitly-Qualified-Segment] {
      <Item {
        @kind = "Reservation";
        emit-needed-reservations ();
      }
    }
    copy { @kind = `@kind`; @line = `@line`; @col = `@col`; }
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind='Reservation']] {
  // do nothing
}