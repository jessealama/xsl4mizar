stylesheet 1.0;

output method=xml indent="yes";

include die.xsl;
include tokens.xsl;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement"]] {
  // do nothing when we encounter these in the default processing
  // mode.
}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement" and not(child::Equality)]] {
  die (#message = "We expect a Type-Changing-Statement item to have an Equality child, but we found one that lacks such a child.");
}

tpl [Text-Proper/Item[@kind = "Type-Changing-Statement" and child::Equality[not(child::Variable)]]] {
  die (#message = "We expected to find a Variable child of the Equality child of the current Type-Changing-Statement that we are handling, but we found none.");
}

tpl [Simple-Term[@idnr = preceding::Item[@kind = "Type-Changing-Statement" and parent::Text-Proper]/Equality/Variable/@idnr]] {
  <Infix-Term {
    for-each [@*] { copy-of `.`; }
    <Arguments;
    <Arguments;
  }
}

// Toplevel theorems (exported or unexported) are checked for whether
// they contain any terms that were introduced by a toplevel
// type-changing statement.  Any such terms are universally
// generalized, with a relativization to the equation introduced by
// type-changing statements.  For example, if we see a toplevel
// type-changing statement
//
// reconsider z = 1 as Element of NAT
//
// before, say,
//
// theorem z is odd;
//
// then we rewrite the theorem as:
//
// theorem for z being Element of NAT st z = 1 holds z is odd;
tpl [Proposition[parent::Item[parent::Text-Proper and @kind = "Regular-Statement" or @kind = "Theorem-Item"]]] {

}

tpl [Block[parent::Item[@kind = "Correctness-Condition"]]] {

}

// * Sometimes type-changing statements don't have an equality: from
// COLLSP:
//
// reconsider Z as non empty set;
//
// * It would appear that some toplevel type changing statements can't
// be eliminated.  An especially problematic case from COLLSP:
//
// reconsider RR = {[1,1,1]} as Relation3 of Z by Def1,Lm2;
// reconsider CLS = CollStr (# Z, RR #) as non empty CollStr;
//
// Lm3: now
//   let a,b,c,p,q,r be Point of CLS;
//   ...
// end;
// ...
// ::> 50: Nongeneralizable variable in the skeleton of a reasoning
//
// One can't just shift those two toplevel type-changing statements
// into the top of the diffuse reasoning block:
//
//
// Lm3: now
//   reconsider RR = {[1,1,1]} as Relation3 of Z by Def1,Lm2;
//   reconsider CLS = CollStr (# Z, RR #) as non empty CollStr;
//   let a,b,c,p,q,r be Point of CLS;
// ::>                      *50
//   ...
// end;
//
// where the explanation of error 50 is: "Nongeneralizable variable in
// the skeleton of a reasoning".