stylesheet 1.0;

output method=xml indent="yes";

include ../utils/die.xsl;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Text-Proper] {
  <Fragments {
    for-each [Item] {
      apply [.] mode="make-item";
    }
  }
}

tpl [*] mode="make-item" {
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    apply [.];
  }
}

tpl [Item[parent::Text-Proper and @kind = "Regular-Statement" and @shape = "Compact-Statement"]] mode="make-item" {
  $context = `.`;
  // look for a sign that we can't promote this toplevel unexported lemma to a proper theorem
  for-each [Proposition] {
    $bad = bad-term-hunting (#candidates = `descendant::Simple-Term`);
    if [$bad = "1"] {
      msg "we cannot promote this lemma to a theorem";
      <Text-Proper {
        <Item { @kind = "Section-Pragma"; }
        apply [$context];
      }
    } else {
      if [descendant::Private-Predicate-Formula] {
        msg "we cannot promote this lemma to a because it contains a private predicate formula";
        <Text-Proper {
          <Item { @kind = "Section-Pragma"; }
          apply [$context];
        }
      } else {
        msg "we can promote this lemma to a theorem";
        <Text-Proper {
          <Item { @kind = "Section-Pragma"; }
          <Item {
            @kind = "Theorem-Item";
            @promoted-lemma = "yes";
            apply [.];
            for-each [following-sibling::*] {
              apply [.];
            }
          }
        }
      }
    }
  }
}

tpl bad-term-hunting (#candidates) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    if [not($candidate/@spelling)] {
      die (#message = "To determine whether there is a bad term in the current item, we require that all terms have a spelling, but we just found a term that lacks one.");
    }
    $spelling = `$candidate/@spelling`;
    $n = `local-name ($candidate)`;
    choose {
      when [$n = "Schematic-Variable"] {
        "1";
      }
      when [starts-with ($spelling, "D")] {
        "1";
      }
      // when [preceding::Item[parent::Text-Proper and @kind = "Choice-Statement"]/*/Variables/Variable[@idnr = $idnr]] {
      //   msg "choice variable introduced";
      //   "1";
      // }
      when [starts-with ($spelling, "C")] {
        msg "choice variable introduced";
        "1";
      }
      otherwise {
        bad-term-hunting (#candidates = `$candidates[position() > 1]`);
      }
    }
  } else {
    "0";
  }
}

tpl [Text-Proper/*/Straightforward-Justification/Link] {
  for-each [../..] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $label = `concat ("CKB", $num-previous)`;
    <Theorem-Reference {
      @spelling = $label;
      @"number" = "1";
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Resolving article-local references
//////////////////////////////////////////////////////////////////////

// Resolving scheme references

tpl [Scheme-Justification[@nr = "0"
                          and @idnr = preceding::Item[parent::Text-Proper
                                                      and @kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme/@idnr]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Scheme-Block-Item" and descendant::Scheme[@idnr = $idnr]]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $spelling = `concat ("CKB", $position)`;
    <Scheme-Justification {
      @spelling = $spelling;
      @idnr = "1";
      @nr = "1"; // might not be right
      @promoted = "promoted";
      apply [`$context/*`];
    }
  }
}

// Non-scheme references

// By default, we don't know how to resolve; just copy.
tpl [Local-Reference] {
  copy-of `.`;
}

// look for a previous unexported-but-exportable toplevel theorem (lemma)
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Regular-Statement"
                                             and @shape = "Compact-Statement"]/Proposition/Label[@idnr]/@idnr]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Regular-Statement"
                            and @shape = "Compact-Statement"]/Proposition[Label[@idnr = $idnr]][1]] {
    $bad = bad-term-hunting (#candidates = `descendant::Simple-Term`);
    if [$bad = "1"] {
      msg "Unable to rewrite a local lemma reference due to unexportability.";
      copy-of `$context`; // the lemma that this local reference refers to cannot be promoted
    } else {
      if [descendant::Private-Predicate-Formula] {
        msg "Unable to rewrite a local lemma reference due to presence of a private predicate symbol.";
        copy-of `$context`; // the lemma that this local reference refers to cannot be promoted
      } else {
        msg "Rewriting a local lemma reference; it is safe because it is exportable";
        $num-previous = `count (preceding::Item[parent::Text-Proper])`;
        $position = `$num-previous + 1`;
        $new_spelling = `concat ("CKB", $position)`;
        <Theorem-Reference {
          @spelling = $new_spelling;
          @promoted = "promoted";
          @"number" = "1";
        }
      }
    }
  }
}

// look for a previous exported toplevel theorem
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Theorem-Item"]/Proposition/Label/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Theorem-Item" and Proposition/Label[@idnr = $idnr]]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous non-mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                                     or @kind = "Attribute-Definition"
                                                                                                                     or @kind = "Predicate-Definition"
                                                                                                                     or @kind = "Structure-Definition"]/Definiens/Label[@idnr]/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                    or @kind = "Attribute-Definition"
                                                                                                    or @kind = "Predicate-Definition"
                                                                                                    or @kind = "Structure-Definition"]/Definiens/Label[@idnr = $idnr]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}
