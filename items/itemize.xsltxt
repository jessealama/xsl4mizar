stylesheet 1.0;

output method=xml indent="yes";

include ../utils/die.xsl;
include ../utils/tokens.xsl;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [Text-Proper] {
  <Fragments {
    for-each [Item] {
      apply [.] mode="make-item";
    }
  }
}

tpl term-with-idnr-occurs-in-context (#idnr) {
  if [descendant::Variable[@idnr = $idnr] | descendant::Simple-Term[@idnr = $idnr]] {
    "1";
  } else {
    "0";
  }
}

tpl reserved-variable-with-idnr-in-context (#idnr) {
  if [@implicitly-qualified-variables] {
    $implicitly-qualified = `@implicitly-qualified-variables`;
    $idnr-token = `concat (",", $idnr, ",")`;
    if [contains ($implicitly-qualified, $idnr-token)] {
      "1";
    } else {
      "0";
    }
  } else {
    if [descendant::Implicitly-Qualified-Segment/Variable[@idnr = $idnr] | descendant::Simple-Term[@idnr = $idnr]] {
      "1";
    } else {
      "0";
    }
  }
}

tpl private-functor-term-with-idnr-occurs-in-context (#idnr) {
  if [descendant::Private-Functor-Term[@idnr = $idnr]] {
    "1";
  } else {
    "0";
  }
}

tpl private-predicate-formula-with-idnr-occurs-in-context (#idnr) {
  if [descendant::Private-Predicate-Formula[@idnr = $idnr]] {
    "1";
  } else {
    "0";
  }
}

tpl some-variable-used-in-context (#variables) {
  if [$variables] {
    $variable = `$variables[1]`;
    $remaining-variables = `$variables[position() > 1]`;
    $variable-idnr = `$variable/@idnr`;
    if [not($variable-idnr)] {
      die (#message = "We found a variable that lacks and idnr attribute!");
    }
    $occurs = term-with-idnr-occurs-in-context (#idnr = $variable-idnr);
    if [$occurs = "1"] {
      "1";
    } else {
      some-variable-used-in-context (#variables = $remaining-variables);
    }
  } else {
    "0";
  }
}

tpl reference-to-label-in-context (#label-idnr) {
  if [descendant::Local-Reference[@idnr = $label-idnr]] {
    "1";
  } else {
    "0";
  }
}

tpl item-uses-item (#item, #user) {
  for-each [$item] {
    choose {
      when [self::Item[@kind = "Reservation"]] {
        $idnr = `Variables/Variable[@idnr]/@idnr`;
        if [not($idnr)] {
          die (#message = "A reservation has a variable that lacks an idnr attribute!");
        }
        for-each [$user] {
          reserved-variable-with-idnr-in-context (#idnr = $idnr);
        }
      }
      when [self::Item[@kind = "Private-Predicate-Definition"]] {
        $idnr = `Variable[@idnr]/@idnr`;
        if [not($idnr)] {
          die (#message = "A private predicate definition has a variable that lacks an idnr attribute!");
        }
        for-each [$user] {
          private-predicate-formula-with-idnr-occurs-in-context (#idnr = $idnr);
        }
      }
      when [self::Item[@kind = "Private-Functor-Definition"]] {
        $idnr = `Variable[@idnr]/@idnr`;
        if [not($idnr)] {
          die (#message = "A private predicate definition has a variable that lacks an idnr attribute!");
        }
        for-each [$user] {
          private-functor-term-with-idnr-occurs-in-context (#idnr = $idnr);
        }
      }
      when [self::Item[@kind = "Type-Changing-Statement"]] {
        $idnr = `Equality/Variable[@idnr]/@idnr`;
        if [not($idnr)] {
          die (#message = "A type-changing statement having the shape of an equality has a variable that lacks an idnr attribute!");
        }
        for-each [$user] {
          term-with-idnr-occurs-in-context (#idnr = $idnr);
        }
      }
      when [self::Item[@kind = "Choice-Statement" and Explicitly-Qualified-Segment]] {
        $variables = `Explicitly-Qualified-Segment/Variables/Variable`;
        for-each [$user] {
          some-variable-used-in-context (#variables = $variables);
        }
      }
      when [self::Item[@kind = "Constant-Definition" and Variable]] {
        $idnr = `Variable[@idnr]/@idnr`;
        if [not($idnr)] {
          die (#message = "A constant definition has a variable that lacks an idnr attribute!");
        }
        for-each [$user] {
          term-with-idnr-occurs-in-context (#idnr = $idnr);
        }
      }
      when [self::Item[@kind = "Regular-Statement" and Proposition and @exportable = "no"]] {
        $label-idnr = `Proposition/Label[@idnr]/@idnr`;
        if [$label-idnr] {
          for-each [$user] {
            reference-to-label-in-context (#label-idnr = $label-idnr);
          }
        }
      }
      when [self::Item[@kind = "Regular-Statement" and not(Proposition) and @exportable = "no"]] {
        $label-idnr = `Label[@idnr]/@idnr`;
        if [$label-idnr] {
          for-each [$user] {
            reference-to-label-in-context (#label-idnr = $label-idnr);
          }
        }
      }
      otherwise {
        $k = `@kind`;
        $message = `concat ("Don't know how to determine whether an element of type ", $k, " is needed.")`;
        die (#message = $message);
      }
    }
  }
}

// Find a path from $start to $end, possibly via the items in
// $between.  The result is either the empty string (indicating that
// there is no path from $start to $end via $beteen), or a token list
// of numbers ',num-1,num-2,...,num-N,'.  The interpretation is that
// item num-1 is item num-1 in the document; it is used by item num-2,
// ..., until we get to item num-N.
// tpl path-from-to (#start, #end, #between, #path-so-far) {
//   $occurs-in-item = item-uses-item (#item = $start, #user = $end);
//   if [$occurs-in-item = "1"] {
//     for-each [$start] {
//       $position-of-start = `count (preceding-sibling::Item) + 1`;
//       cons-token-string-at-end (#item = $position-of-start, #token-string = $path-so-far);
//     }
//   } else {
//     if [$between] {
//       $later-candidates = `$between[position() > 1]`;
//       $candidate = `$between[1]`;
//       $path-from-candidate = path-from-to (#start = $candidate, #end = $end, #between = $later-candidates);
//       if [$path-from-candidate = ""] { // there is no path
//         path-from-to (#start = $start, #end = $end, #between = $later-candidates);
//       } else {
//         $candidate-uses = item-uses-item (#user = $candidate, #item = $start);
//         if [$candidate-uses = "1"] {
//           for-each [$candidate] {
//             $path-with-candidate-at-end = cons-token-string-at-end (#item = `count (preceding-sibling::Item) + 1`,
//                                                                     #token-string = $path-so-far);
//             for-each [$end] {
//               cons-token-string-at-end (#item = `count (preceding-sibling::Item) + 1`,
//                                         #token-string = $path-with-candidate-at-end);
//             }
//           }
//         } else {
//           path-from-to (#start = $start, #end = $end, #between = $later-candidates, #path-so-far = $path-so-far);
//         }
//       }
//     } else {
//       ""; // no path
//     }
//   }
// }

// Find a path from $start to $end, possibly via the items in
// $between.  The result is either the empty string (indicating that
// there is no path from $start to $end via $beteen), or a token list
// of numbers ',num-1,num-2,...,num-N,'.  The interpretation is that
// item num-1 is item num-1 in the document; it is used by item num-2,
// ..., until we get to item num-N.
tpl path-from-to (#start, #end, #between, #path-so-far, #dead-ends) {
  for-each [$start] {
    $position-of-start = `count (preceding-sibling::Item) + 1`;
    $start-token = `concat (",", $position-of-start, ",")`;
    if [contains ($dead-ends, $start-token)] {
      // $dead-ends already starts with a comma
      if [not(starts-with ($dead-ends, ","))] {
        $message = `concat ("The dead-ends token list is nonempty, but it does not start with a comma!  It is '", $dead-ends, "'")`;
        die (#message = $message);
      }
      `concat ("", ",", $dead-ends)`;
    } else {
      $occurs-in-item = item-uses-item (#item = $start, #user = $end);
      if [$occurs-in-item = "1"] {
        $path = cons-token-string-at-end (#item = $position-of-start, #token-string = $path-so-far);
        if [$dead-ends = ""] {
          // $path ends with a comma
          $solution = `concat ($path, ",,", "")`;
          $message = `concat ("Solution [1] is '", $solution, "'")`;
          // msg $message;
          $solution;
        } else {
          $solution = `concat ($path, ",,", $dead-ends)`;
          $message = `concat ("Solution [2] is '", $solution, "'")`;
          // msg $message;
          $solution;
        }
      } else {
        if [$between] {
          $later-candidates = `$between[position() > 1]`;
          $candidate = `$between[1]`;
          for-each [$candidate] {
            $candidate-position = `count (preceding-sibling::Item) + 1`;
            $candidate-token = `concat (",", $candidate-position, ",")`;
            if [contains ($dead-ends, $candidate-token)] {
              path-from-to (#start = $start, #end = $end, #between = $later-candidates, #path-so-far = $path-so-far, #dead-ends = $dead-ends);
            } else {
              $solution-from-candidate = path-from-to (#start = $candidate, #end = $end, #between = $later-candidates, #path-so-far = $path-so-far, #dead-ends = $dead-ends);
              $path-from-candidate = `substring-before ($solution-from-candidate, ",,")`;
              $more-dead-ends = `substring-after ($solution-from-candidate, ",,")`;
              if [$path-from-candidate = ""] { // there is no path
                $new-dead-ends = cons-token-string-at-end (#item = $candidate-position, #token-string = $more-dead-ends);
                path-from-to (#start = $start, #end = $end, #between = $later-candidates, #path-so-far = $path-so-far, #dead-ends = $new-dead-ends);
              } else {
                $candidate-uses = item-uses-item (#user = $candidate, #item = $start);
                if [$candidate-uses = "1"] {
                  $path-with-candidate-at-end = cons-token-string-at-end (#item = $candidate-position,
                                                                          #token-string = $path-so-far);
                  for-each [$end] {
                    $solution-path = cons-token-string-at-end (#item = `count (preceding-sibling::Item) + 1`, #token-string = $path-with-candidate-at-end);
                    if [$dead-ends = ""] {
                      // $solution-path ends with a comma; only one new one is needed
                      $solution = `concat ($solution-path, ",,", "")`;
                      $message = `concat ("Solution [3] is '", $solution, "'")`;
                      // msg $message;
                      $solution;
                    } else {
                      // $dead-ends ends with a comma, as does $solution-path, so no new comma is needed
                      $solution = `concat ($solution-path, ",,", $dead-ends)`;
                      $message = `concat ("Solution [4] is '", $solution, "'")`;
                      // msg $message;
                      $solution;
                    }
                  }
                } else {
                  path-from-to (#start = $start, #end = $end, #between = $later-candidates, #path-so-far = $path-so-far, #dead-ends = $dead-ends);
                }
              }
            }
          }
        } else {
          $new-dead-ends = cons-token-string-at-end (#item = $position-of-start, #token-string = $dead-ends);
          // $new-dead-ends starts with a comma
          $solution = `concat ("", ",,", $new-dead-ends)`;
          $message = `concat ("Solution [5] is '", $solution, "'")`;
          // msg $message;
          $solution;
        }
      }
    }
  }
}

tpl needed-for-item (#item, #candidates, #registered-paths) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    $later-candidates = `$candidates[position() > 1]`;
    for-each [$candidate] {
      $candidate-num = `count (preceding-sibling::Item) + 1`;
      $token = `concat (",", $candidate-num, ",")`;
      if [contains ($registered-paths, $token)] {
        $message = "We already know about this path";
        // msg $message;
        apply [$candidate];
        needed-for-item (#item = $item, #candidates = $later-candidates, #registered-paths = $registered-paths);
      } else {
        $path-solution = path-from-to (#start = $candidate, #end = $item, #between = $later-candidates);
        if [not(contains ($path-solution, ",,"))] {
          $message = `concat ("Path solution does not contain two consecutive commas! (it is '", $path-solution, "')")`;
          die (#message = $message);
        }
        $path = `substring-before ($path-solution, ",,")`;
        $dead-ends = `substring-after ($path-solution, ",,")`;
        if [$path = ""] { // there is no path
          // msg "No path.";
          needed-for-item (#item = $item, #candidates = $later-candidates, #registered-paths = $registered-paths);
        } else {
          $message = `concat ("We found a path: ", $path)`;
          // msg $message;
          apply [$candidate];
          $new-registered-paths = append-token-strings (#token-string-a = $registered-paths,
                                                        #token-string-b = $path);
          needed-for-item (#item = $item, #candidates = $later-candidates, #registered-paths = $new-registered-paths);
        }
      }
    }
  }
}

tpl prepend-context-for-item (#item) {
  for-each [$item] {
    $num-prev = `count (preceding::Item[parent::Text-Proper])`;
    $message = `concat ("Computing needed.  There are ", $num-prev, " previous items")`;
    // msg $message;
  }
  needed-for-item (#item = $item,
                   #candidates = `preceding::Item[parent::Text-Proper
                                                  and (@kind = "Reservation"
                                                       or @kind = "Type-Changing-Statement"
                                                       or (@kind = "Regular-Statement" and @exportable = "no")
                                                       or @kind = "Choice-Statement"
                                                       or @kind = "Constant-Definition"
                                                       or @kind = "Private-Predicate-Definition"
                                                       or @kind = "Private-Functor-Definition")]`,
                   #registered-paths = "");
}

tpl [*[not(parent::Text-Proper)]] mode="make-item" {
  msg terminate="yes" "Why are we attepting to make an item from a non-toplevel item?";
}

tpl [*[parent::Text-Proper]] mode="make-item" {
  $context = `.`;
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    prepend-context-for-item (#item = $context);
    apply [.];
  }
}

tpl [Item[parent::Text-Proper
          and @kind = "Regular-Statement"
          and @exportable = "yes"]] mode="make-item" {
  $context = `.`;
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    prepend-context-for-item (#item = $context);
    for-each [Proposition] {
      <Item {
        @kind = "Theorem-Item";
        @promoted-lemma = "yes";
        @lemma-number = `count (preceding::Item[parent::Text-Proper and @kind = "Regular-Statement"]) + 1`;
        apply [.];
        for-each [following-sibling::*] {
          apply [.];
        }
      }
    }
  }
}

tpl [Item[parent::Text-Proper
          and @kind = "Regular-Statement"
          and @exportable = "no"]] mode="make-item" {
  $context = `.`;
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    prepend-context-for-item (#item = $context);
    <Item {
      for-each [@*] { copy-of `.`; }
      @promoted-lemma = "no";
      @lemma-number = `count (preceding::Item[parent::Text-Proper and @kind = "Regular-Statement"]) + 1`;
      apply [*];
    }
  }
}

tpl [Item[parent::Text-Proper and @kind = "Theorem-Item"]] mode="make-item" {
  $context = `.`;
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    prepend-context-for-item (#item = $context);
    <Item {
      for-each [@*] { copy-of `.`; }
      @promoted-lemma = "no";
      @theorem-number = `count (preceding-sibling::Item[@kind = "Theorem-Item"]) + 1`;
      @lemma-number = `count (preceding::Item[parent::Text-Proper and @kind = "Regular-Statement"]) + 1`;
      apply [*];
    }
  }
}

tpl bad-term-hunting (#candidates) {
  if [$candidates] {
    $candidate = `$candidates[1]`;
    if [not($candidate/@spelling)] {
      die (#message = "To determine whether there is a bad term in the current item, we require that all terms have a spelling, but we just found a term that lacks one.");
    }
    $spelling = `$candidate/@spelling`;
    $n = `local-name ($candidate)`;
    choose {
      when [$n = "Schematic-Variable"] {
        "1";
      }
      when [starts-with ($spelling, "D")] {
        "1";
      }
      when [starts-with ($spelling, "C")] {
        "1";
      }
      otherwise {
        bad-term-hunting (#candidates = `$candidates[position() > 1]`);
      }
    }
  } else {
    "0";
  }
}

tpl [Text-Proper/*/Straightforward-Justification/Link] {
  for-each [../..] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $label = `concat ("CKB", $num-previous)`;
    <Theorem-Reference {
      @spelling = $label;
      @"number" = "1";
    }
  }
}

//////////////////////////////////////////////////////////////////////
// Resolving article-local references
//////////////////////////////////////////////////////////////////////

// Resolving scheme references

tpl [Scheme-Justification[@nr = "0"
                          and @idnr = preceding::Item[parent::Text-Proper
                                                      and @kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr]/@idnr]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Scheme-Block-Item" and descendant::Scheme[@idnr = $idnr]][1]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $spelling = `concat ("CKB", $position)`;
    <Scheme-Justification {
      @spelling = $spelling;
      @idnr = "1";
      @nr = "1"; // might not be right
      @promoted = "promoted";
      apply [`$context/*`];
    }
  }
}

// Non-scheme references

// By default, we don't know how to resolve; just copy.
tpl [Local-Reference] {
  copy-of `.`;
}

// look for a previous unexported-but-exportable toplevel theorem (lemma)
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Regular-Statement"
                                             and @shape = "Compact-Statement"]/Proposition/Label[@idnr]/@idnr]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Regular-Statement"
                            and @shape = "Compact-Statement"]/Proposition[Label[@idnr = $idnr]][1]] {
    $bad = bad-term-hunting (#candidates = `descendant::Simple-Term`);
    choose {
      when [$bad = "1"] {
        copy-of `$context`; // the lemma that this local reference refers to cannot be promoted
      }
      when [descendant::Private-Predicate-Formula] {
        copy-of `$context`; // the lemma that this local reference refers to cannot be promoted
      }
      when [descendant::Private-Functor-Term] {
        copy-of `$context`; // the lemma that this local reference refers to cannot be promoted
      }
      otherwise {
        $num-previous = `count (preceding::Item[parent::Text-Proper])`;
        $position = `$num-previous + 1`;
        $new_spelling = `concat ("CKB", $position)`;
        <Theorem-Reference {
          @spelling = $new_spelling;
          @promoted = "promoted";
          @"number" = "1";
        }
      }
    }
  }
}

// look for a previous exported toplevel theorem
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Theorem-Item"]/Proposition/Label/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Theorem-Item" and Proposition/Label[@idnr = $idnr]]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous non-mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                                     or @kind = "Attribute-Definition"
                                                                                                                     or @kind = "Predicate-Definition"
                                                                                                                     or @kind = "Structure-Definition"]/Definiens/Label[@idnr]/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                    or @kind = "Attribute-Definition"
                                                                                                    or @kind = "Predicate-Definition"
                                                                                                    or @kind = "Structure-Definition"]/Definiens/Label[@idnr = $idnr]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[@kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}
