stylesheet 1.0;

output method=xml indent="yes";

include ../utils/die.xsl;

// default: copy

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [/] {
  if [Text-Proper] {
    apply [Text-Proper];
  } else {
    die (#message = "The required Text-Proper element is missing!");
  }
}

tpl [Text-Proper] {
  <Fragments {
    for-each [Item] {
      apply [.] mode="make-item";
    }
  }
}

tpl [*] mode="make-item" {
  <Text-Proper {
    <Item { @kind = "Section-Pragma"; }
    apply [.];
  }
}

// Resolving scheme references

tpl [Scheme-Justification[@nr = "0" and not(@idnr)]] {
  die (#message = "We found an article-local Scheme-Justification that lacks an idnr attribute!");
}

tpl [Scheme-Justification[@nr = "0"
                          and not(@idnr = preceding::Item[parent::Text-Proper
                                                          and @kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme/@idnr)]] {
  die (#message = "Unable to resolve a reference to an article-local scheme because we are unable to find a previous scheme under the same name");
}

tpl [Scheme-Justification[@nr = "0"
                          and @idnr = preceding::Item[parent::Text-Proper
                                                      and @kind = "Scheme-Block-Item"]/Block[@kind = "Scheme-Block"]/Item[@kind = "Scheme-Head"]/Scheme[@idnr]/@idnr]] {
  $context = `.`;
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Scheme-Block-Item" and descendant::Scheme[@idnr = $idnr]][1]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $spelling = `concat ("CKB", $position)`;
    <Scheme-Justification {
      @spelling = $spelling;
      @idnr = "1";
      @nr = "1"; // might not be right
      @promoted = "promoted";
      apply [`$context/*`];
    }
  }
}

// Non-scheme references

// By default, we don't know how to resolve; just copy.
tpl [Local-Reference] {
  copy-of `.`;
}

// look for a previous unexported-but-exportable toplevel theorem (lemma)
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Regular-Statement"
                                             and @shape = "Compact-Statement"]/Proposition/Label[@idnr]/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Regular-Statement"
                            and @shape = "Compact-Statement"
                            and Proposition/Label[@idnr = $idnr]][1]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous exported toplevel theorem
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Theorem-Item"]/Proposition/Label/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper and @kind = "Theorem-Item" and Proposition/Label[@idnr = $idnr]]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Theorem-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous non-mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                                     or @kind = "Attribute-Definition"
                                                                                                                     or @kind = "Predicate-Definition"
                                                                                                                     or @kind = "Structure-Definition"]/Definiens/Label[@idnr]/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[parent::Text-Proper
                            and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Functor-Definition"
                                                                                                    or @kind = "Attribute-Definition"
                                                                                                    or @kind = "Predicate-Definition"
                                                                                                    or @kind = "Structure-Definition"]/Definiens/Label[@idnr = $idnr]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}

// look for a previous mode definition
tpl [Local-Reference[@idnr = preceding::Item[parent::Text-Proper
                                             and @kind = "Definition-Item"]/Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr]/@idnr]] {
  $idnr = `@idnr`;
  for-each [preceding::Item[@kind = "Definition-Item"
                            and Block[@kind = "Definitional-Block"]/Item[@kind = "Mode-Definition"]/*/Definiens/Label[@idnr = $idnr]]] {
    $num-previous = `count (preceding::Item[parent::Text-Proper])`;
    $position = `$num-previous + 1`;
    $new_spelling = `concat ("CKB", $position)`;
    <Definition-Reference {
      @spelling = $new_spelling;
      @promoted = "promoted";
      @"number" = "1";
    }
  }
}