// nd.xsltxt : Transform mizar proofs into Gentzen-style natural deductions

stylesheet "1.0";

output method="xml" encoding="utf-8" indent="yes";

include utils/die.xsl;

// This stylesheet works on the XML emitted by the mizar analyzer.
// The input is thus the XMLization of a whole mizar article.  We will
// process only toplevel theorems.

tpl list (#separ, #elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { copy-of $separ; } }
}

key "formulas" [/tstp/formula[@name]] `@name`;
key "symbols" [/tstp/formula/source[descendant::non-logical-data[@name = "new_symbol"]]] `descendant::non-logical-data[@name = "new_symbol"]/non-logical-data/@name`;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

tpl [/] {
  apply [tstp];
}

tpl [tstp] {
  apply [formula[position() = last()]];
}

tpl [formula[not(@name)]] {
  die (#message = "We requre that formula elements have names");
}

tpl [formula[@name and @status = "plain" and not(descendant::non-logical-data[@name = "mizar_by"])]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "implication-elimination";
    }
    apply [source];
  }
}

tpl [formula[@name and @status = "plain" and descendant::non-logical-data[@name = "mizar_by"]]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "by";
    }
    for-each [source/non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
      <Derivation {
        @"name" = `@name`;
        <Rule {
          @"name" = "axiom";
        }
      }
    }
  }
}

tpl [formula[@name and @status = "assumption"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "axiom";
    }
  }
}

tpl [formula[@name and @status = "definition"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "definition";
    }
  }
}

// The weird xpath predicate is designed to rule out applying this
// template to the final formula of the TSTP problem whose status is
// 'theorem'.  The final formula whose status is 'theorem' is not to
// be treated as an axiom.
tpl [formula[@name and @status = "theorem" and following-sibling::formula[@status = "theorem"]]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "axiom";
    }
  }
}

tpl [formula[@name and @status = "theorem"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      if [following-sibling::formula[@status = "theorem"]] {
        @"name" = "axiom";
      } else {
        @"name" = "implication-elimination";
      }
    }
    apply [source];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "let"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "conclusion"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "discharge_asm"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "mizar_by"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "introduced" and child::non-logical-data[@name = "tautology"]]]] {
  // do nothing
}
