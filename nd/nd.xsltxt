// nd.xsltxt : Transform mizar proofs into Gentzen-style natural deductions

stylesheet "1.0";

output method="xml" encoding="utf-8" indent="yes";

include ../utils/die.xsl;

tpl list (#separ, #elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { copy-of $separ; } }
}

key "formulas" [/tstp/formula[@name]] `@name`;
key "symbols" [/tstp/formula/source[descendant::non-logical-data[@name = "new_symbol"]]] `descendant::non-logical-data[@name = "new_symbol"]/non-logical-data/@name`;

tpl [*] {
  $element = `local-name ()`;
  <$element {
    for-each [@*] { copy-of `.`; }
    apply [*];
  }
}

//////////////////////////////////////////////////////////////////////
// Sanity checks as templates
//////////////////////////////////////////////////////////////////////

tpl [formula[not(@name)]] mode="sanity-check" {
  die (#message = "We requre that formula elements have names");
}

tpl [formula[not(@status)]] mode="sanity-check" {
  die (#message = "We requre that formula elements have a status!");
}

tpl [formula[@status and not(@status = "plain"
                             or @status = "assumption"
                             or @status = "definition"
                             or @status = "axiom"
                             or @status = "theorem")]] mode="sanity-check" {
  $status = `@status`;
  $message = `concat ("We know how to deal only with the with formula elements whose status is one of these kinds: plain, assumption, definition, axiom, theorem.  The status of the current formula element is '", $status, "'")`;
  die (#message = $message);
}

tpl [/] mode="sanity-check" {
  apply [descendant::formula] mode="sanity-check";
}

tpl [/] {
  if [not(tstp)] {
    die (#message = "The required tstp element is missing!");
  }
  apply [.] mode="sanity-check";
  apply [tstp];
}

tpl [tstp] {
  if [not(formula)] {
    die (#message = "We require that a tstp element have at least one formula child element!");
  }
  apply [formula[position() = last()]];
}

tpl [formula[@name and @status = "plain" and not(descendant::non-logical-data[@name = "mizar_by"])]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "implication-elimination";
    }
    apply [source];
  }
}

tpl [formula[@name and @status = "plain" and descendant::non-logical-data[@name = "mizar_by"]]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "by";
    }
    for-each [source/non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
      $premise-name = `@name`;
      $premise = `key ("formulas", $premise-name)`;
      if [$premise] {
        apply [$premise];
      } else {
        <Deriviation {
          @"name" = $premise-name;
          <Rule {
            @"name" = "axiom";
          }
        }
      }
    }
  }
}

tpl [formula[@name and @status = "assumption"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "axiom";
    }
  }
}

tpl [formula[@name and @status = "definition"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "definition";
    }
  }
}

tpl [formula[@name and @status = "axiom"]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "axiom";
    }
  }
}

// The weird xpath predicate is designed to rule out applying this
// template to the final formula of the TSTP problem whose status is
// 'theorem'.  The final formula whose status is 'theorem' is not to
// be treated as an axiom.
tpl [formula[@name and @status = "theorem" and following-sibling::formula[@status = "theorem"]]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      @"name" = "axiom";
    }
  }
}

tpl [formula[@name and @status = "theorem" and not(following-sibling::formula[@status = "theorem"])]] {
  <Derivation {
    @"name" = `@name`;
    apply [*[1]]; // the actual formula
    <Rule {
      if [following-sibling::formula[@status = "theorem"]] {
        @"name" = "axiom";
      } else {
        @"name" = "implication-elimination";
      }
    }
    apply [source];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "let"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "conclusion"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "discharge_asm"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "inference" and child::non-logical-data[@name = "mizar_by"]]]] {
  for-each [non-logical-data/non-logical-data[position() = last()]/non-logical-data[@name]] {
    $premise-name = `@name`;
    $premise = `key ("formulas", $premise-name)`;
    if [not($premise)] {
      $message = `concat ("We failed to look up the formula whose name is '", $premise-name, "'")`;
      die (#message = $message);
    }
    apply [$premise];
  }
}

tpl [source[child::non-logical-data[@name = "introduced" and child::non-logical-data[@name = "tautology"]]]] {
  // do nothing
}
