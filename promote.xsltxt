stylesheet 1.0;

output method=xml indent="yes";

include die.xsl;

// The target constructor kind
#kind = { ""; }

// The target constructor nr
#nr = { ""; }

// The target constructor relnr
#relnr = { ""; }

// The target constructor's article
#aid = { ""; }

tpl [*] {
  $element = `local-name ()`;
  if [*] {
    <$element {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  } else {
    <$element {
      for-each [@*] { copy-of `.`; }
    }
  }
}

tpl [/] {
  apply [Constructors];
}

tpl escape-backslash (#str) {
  if [contains ($str, '/')] {
    $before = `substring-before ($str, '/')`;
    $after = `substring-after ($str, '/')`;
    $tail = escape-backslash (#str = $after);
    `concat ($before, "&amp;#47;", $tail)`;
  } else {
    $str;
  }
}

tpl [Constructors] {
  <Constructors {
    @aid = `@aid`;
    @mizfiles = escape-backslash (#str = `@mizfiles`);
    apply [Constructor];
  }
}

// Promote a bundle of argument types to a bundle of 'set' types
tpl [ArgTypes] mode="promote" {
  <ArgTypes {
    for-each [*] {
      apply [.] mode="promote";
    }
  }
}

tpl [Properties] mode="promote" {
  <Properties; // empty list of properties
}

// Promote a type to the topmost type 'set'
tpl [Typ] mode="promote" {
  <Typ {
    @kind = "M";
    @nr = "1";
    <Cluster;
  }
}

tpl [Constructor[@kind = "M"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "M" and $nr = @nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote";
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote";
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

// For right functor brackets, there is nothing to do
tpl [Constructor[@kind = "L"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "L"] {
      msg terminate="no" "Promoting a right functor bracket; there is nothing to do.";
      @promoted = "yes";
    } else {
      @promoted = "no";
    }
    apply [*];
  }
}

tpl [Constructor[@kind = "G"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "G" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
      // result type: "mere structure".  We might also experiment with making the return type 'set'.  But this might screw up too much.
      <Typ {
        @kind = "G";
        @nr = "1";
        <Cluster;
      }
      apply [Fields]; // nothing to do here
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "U"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "U" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote"; // result type
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "V"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "V" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "R"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "R" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote"; // ignore properties
      apply [ArgTypes] mode="promote"; // argument types
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "K"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "K" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote"; // ignore properties
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote"; // result type
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}
