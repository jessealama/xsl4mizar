stylesheet 1.0;

output method=xml indent="yes";

include die.xsl;
include tokens.xsl;

// This stylesheet operates on .atr files output by the mizar
// accommodator. The result is another .atr file. There are four
// parameters:
//
// * kind
// * nr
// * relnr
// * aid
//
// and searches a given .atr file for a constructor identified by
// these four criteria. Each of these four parameters should be token
// lists; the interpretation is the the four parameters specify a set
// of constructors.  If there is no constructor that matches all these
 // criteria, the result is an unchanged .atr file ("unchanged"
 // means: up to whitespace differences and any XSL processing
 // instructions). Any constructor that matches these criteria
 // (there should be only one) will be "promoted" in the sense that
 // its arguments (if there are any) will be assumed to take terms
 // of type 'set', and the "result value", if any, will also be
 // promoted to the type 'set'. (There is an exception to this rule:
 // structure constructors will be promoted to have the "result
 // type" of a 'mere structure', and not the type 'set'.)

// The target constructor kind
#kind-list = { ""; }

// The target constructor nr
#nr-list = { ""; }

// The target constructor relnr
#relnr-list = { ""; }

// The target constructor's article
#aid-list = { ""; }

tpl [*] {
  $element = `local-name ()`;
  if [*] {
    <$element {
      for-each [@*] { copy-of `.`; }
      apply [*];
    }
  } else {
    <$element {
      for-each [@*] { copy-of `.`; }
    }
  }
}

tpl ensure-valid-token-strings {
  $kind-ok = ensure-token-string (#string = $kind-list);
  if [$kind-ok = "1"] {
    $nr-ok = ensure-token-string (#string = $nr-list);
    if [$nr-ok = "1"] {
      $relnr-ok = ensure-token-string (#string = $relnr-list);
      if [$relnr-ok = "1"] {
        $aid-ok = ensure-token-string (#string = $aid-list);
        if [$aid-ok = "1"] {
          "1";
        } else {
          $message = `concat ("The aid token string '", $aid-list, "' is not a valid token string")`;
          die (#message = $message);
        }
      } else {
        $message = `concat ("The relnr token string '", $relnr-list, "' is not a valid token string")`;
        die (#message = $message);
      }
    } else {
      $message = `concat ("The nr token string '", $nr-list, "' is not a valid token string")`;
      die (#message = $message);
    }
  } else {
    $message = `concat ("The kind token string '", $kind-list, "' is not a valid token string")`;
    die (#message = $message);
  }
}

tpl ensure-equal-length-token-strings {
  $kind-length = token-string-length (#token-string = $kind-list);
  $nr-length = token-string-length (#token-string = $nr-list);
  if [$kind-length = $nr-length] {
    $relnr-length = token-string-length (#token-string = $relnr-list);
    if [$kind-length = $relnr-length] {
      $aid-length = token-string-length (#token-string = $aid-list);
      if [$kind-length = $aid-length] {
        "1";
      } else {
        $message = `concat ("The kind token string '", $kind-list, "' has ", $kind-length, " items, whereas the aid token string '", $aid-list, "' has ", $aid-length, " items.  Since these are different, we cannot proceed.")`;
        die (#message = $message);
      }
    } else {
      $message = `concat ("The kind token string '", $kind-list, "' has ", $kind-length, " items, whereas the relnr token string '", $relnr-list, "' has ", $relnr-length, " items.  Since these are different, we cannot proceed.")`;
      die (#message = $message);
    }
  } else {
    $message = `concat ("The kind token string '", $kind-list, "' has ", $kind-length, " items, whereas the nr token string '", $nr-list, "' has ", $nr-length, " items.  Since these are different, we cannot proceed.")`;
    die (#message = $message);
  }
}

tpl [/] {
  ensure-valid-token-strings ();
  ensure-equal-length-token-strings ();
  apply [Constructors];
}

tpl escape-backslash (#str) {
  if [contains ($str, '/')] {
    $before = `substring-before ($str, '/')`;
    $after = `substring-after ($str, '/')`;
    $tail = escape-backslash (#str = $after);
    `concat ($before, "&amp;#47;", $tail)`;
  } else {
    $str;
  }
}

tpl [Constructors] {
  <Constructors {
    @aid = `@aid`;
    @mizfiles = escape-backslash (#str = `@mizfiles`);
    apply [Constructor];
  }
}

// Promote a bundle of argument types to a bundle of 'set' types
tpl [ArgTypes] mode="promote" {
  <ArgTypes {
    for-each [*] {
      apply [.] mode="promote";
    }
  }
}

tpl [Properties] mode="promote" {
  <Properties; // empty list of properties
}

// Promote a type to the topmost type 'set'
tpl [Typ] mode="promote" {
  <Typ {
    @kind = "M";
    @nr = "1";
    <Cluster;
  }
}

tpl [Constructor[@kind = "M"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "M" and $nr = @nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote";
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote";
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

// For right functor brackets, there is nothing to do
tpl [Constructor[@kind = "L"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "L"] {
      msg terminate="no" "Promoting a right functor bracket; there is nothing to do.";
      @promoted = "yes";
    } else {
      @promoted = "no";
    }
    apply [*];
  }
}

tpl [Constructor[@kind = "G"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "G" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
      // result type: "mere structure".  We might also experiment with making the return type 'set'.  But this might screw up too much.
      <Typ {
        @kind = "G";
        @nr = "1";
        <Cluster;
      }
      apply [Fields]; // nothing to do here
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "U"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "U" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote"; // result type
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "V"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "V" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [ArgTypes] mode="promote"; // argument types
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "R"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "R" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote"; // ignore properties
      apply [ArgTypes] mode="promote"; // argument types
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}

tpl [Constructor[@kind = "K"]] {
  <Constructor {
    for-each [@*] { copy-of `.`; }
    if [$kind = "K" and @nr = $nr and @relnr = $relnr and @aid = $aid] {
      @promoted = "yes";
      apply [Properties] mode="promote"; // ignore properties
      apply [ArgTypes] mode="promote"; // argument types
      apply [Typ] mode="promote"; // result type
    } else {
      @promoted = "no";
      apply [*];
    }
  }
}
