stylesheet 1.0;
output method=text;

// List utilities.  Stolen from Josef.  Thanks, Josef.

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { copy-of $separ; } }
}

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// name of current article (upper case)
#aname= { `string(/*/@articleid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }

// .idx file with identifier names
#ids=  { `concat($anamelc, '.idx')`; }

tpl get_vid_name(#vid)
{
  for-each [document($ids, /)] 
  { 
     for-each [key('D_I', $vid)] { `@name`; }
  }
}

tpl die(#message) {
  if [@line and @col] {
    $line = `@line`;
    $col = `@col`;
    $final_message = `concat ($message, " (line ", $line, ", column ", $col, ")")`;
    msg terminate="yes" $final_message;
  } else {
    $final_message = `concat ($message, " (unable to determine line and column information)")`;
    msg terminate="yes" $final_message;
  }
}

tpl [Text-Proper] {
  for-each [Item] {
    apply [.];
  }
}

tpl [Variable] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Variable missing a spelling!");
  }
}

tpl [Standard-Type] {
  if [@spelling] {
    `@spelling`;
    if [Infix-Term | Simple-Term | Private-Functor-Term | Circumfix-Term | Qualification-Term] {
      " of ";
      list (#separ = ",", #elems = `Infix-Term | Simple-Term | Private-Functor-Term | Circumfix-Term | Qualification-Term`);
    }
  } else {
    die (#message = "Standard-Type lacks a spelling!");
  }
}

tpl [Item[@kind='Reservation']] {
  "reserve ";
  list (#separ = ",", #elems = `Variable`);
  " ";
  "for ";

  // sanity check: one and only one type
  if [Standard-Type | Clustered-Type] {
    apply [(Standard-Type | Clustered-Type)[1]]; ";"; "\n";
  } else {
    die(#message="No type (neither a Standard-Type nor a Clustered-Type) was found under a Reservation!");
  }
}

tpl [Item[@kind='Section-Pragma']] {
  "begin"; "\n";
}

tpl [Item[@kind='Per-Cases']] {
  if [Straightforward-Justification] {
    "per cases"; apply [Straightforward-Justification[1]]; ";"; "\n";
  } else {
    die (#message = "Don't know how to deal with a Per-Cases item that lacks a Straightforward-Justification child!");
  }
}

tpl [Item[@kind='Case-Block']] {
  if [Block[@kind='Suppose']] {
    apply [Block[@kind='Suppose'][1]]; // could there be more than one?
  } else {
    if [Block[@kind='Case']] {
      apply [Block[@kind='Case'][1]];
    } else {
      die (#message = "Don't know how to deal with a Case-Block item that lacks both a Suppose block and Case block child!");
    }
  }
}

tpl [Block[@kind='Case']] {
  if [Item[@kind='Case-Head']] {
    apply [Item[@kind='Case-Head'][1]]; ";"; "\n";
    apply [*[position() > 1]]; // assuming that the Case-Head is the first child
    "end;"; "\n";
  } else {
    die (#message = "Don't know how to deal with a Case block that lacks a Case-Head item child!");
  }
}

tpl [Block[@kind='Suppose']] {
  if [Item[@kind='Suppose-Head']] {
    apply [Item[@kind='Suppose-Head'][1]];
    apply [*[position() > 1]]; // assuming that the Suppose-Head element is at position 1
    "end;"; "\n";
  } else {
    die (#message = "Don't know hot to deal with a Suppose block that lacks a Suppose-Head child!");
  }
}

tpl [Item[@kind='Case-Head']] {
  if [Single-Assumption] {
    "case "; apply [Single-Assumption[1]];
  } else {
    die (#message = "Don't know how to deal with a Suppose-Head item that lacks a Single-Assumption child!");
  }
}

tpl [Item[@kind='Suppose-Head']] {
  if [Single-Assumption] {
    "suppose "; apply [Single-Assumption[1]]; ";"; "\n";
  } else {
    die (#message = "Don't know how to deal with a Suppose-Head item that lacks a Single-Assumption child!");
  }
}

tpl [Item[@kind='Scheme-Block-Item']] {

  // sanity check: there is one and only one Scheme-Block child
  if [Block[@kind='Scheme-Block']] {
    if [Block[@kind='Scheme-Block'][2]] {
      die(#message = "Multiple Scheme-Block children of a Scheme-Block-Item!");
    } else {
      apply[Block[@kind='Scheme-Block'][1]];
    }
  } else {
    die(#message = "Scheme-Block child of a Scheme-Block-Item is missing!");
  }
}

tpl [Block[@kind='Scheme-Block']] {

  // sanity check: there is one and only one Scheme-Head child
  if [Item[@kind='Scheme-Head']] {
    if [Item[@kind='Scheme-Head'][2]] {
      die(#message = "Multiple Scheme-Head children of a Scheme-Block!");
    } else {
      apply [Item[@kind='Scheme-Head'][1]];
      if [*[2]] { // I guess this is the proof
        "\n";
        "proof";
        "\n";
        apply [*[position() > 1]];
        "end";
	";";
	"\n";
      }
    }
  } else {
    die(#message = "Scheme-Head child of Scheme-Block is missing!");
  }
}

tpl [Item[@kind='Definition-Item']] {
  apply [*[1]];
}

tpl [Type-Specification] {
  apply [*]; // ...
}

tpl [Equals] {
  "equals";
}

tpl [Means] {
  "means";
}

tpl [Formula-Expression] {
  // do nothing.  This is an element found as a child of Definiens
  // elements that simply indicates that the definiens has the shape
  // of a formula, as opposed to a term.
}

tpl [Term-Expression] {
  // do nothing.  This is an element found as a child of Definiens
  // elements that simply indicates that the definiens has the shape
  // of a term, as opposed to a formula.
}

tpl [it-Term] {
  "it";
}

// Standard-Mode elements suck
tpl [Standard-Mode] {
  if [Definiens] {
    apply [Definiens[1]]; ";"; "\n";
  } else {
    if [Type-Specification] {
      apply [Type-Specification[1]]; ";"; "\n";
    } else {
      die (#message = "Don't know how to deal with a Standard-Mode element that lacks a Definiens child!");
    }
  }
}

tpl [Expandable-Mode] {
  if [Standard-Type | Clustered-Type] {
    " is ";
    apply [(Standard-Type | Clustered-Type)[1]];
  } else {
    die (#message = "Don't know how to deal with an Expandable-Mode element that lacks a Standard-Type and Clustered-Type child!");
  }
}

tpl [Item[@kind='Mode-Definition']] {
  if [Redefine] {
    "redefine ";
  }
  "mode ";
  if [Mode-Pattern] {
    apply [Mode-Pattern[1]]; "\n";
  } else {
    die (#message = "Mode-Definition element lacks a Mode-Pattern child!");
  }
  if [Standard-Mode/Type-Specification] {
    " -> "; apply [Standard-Mode[1]];
  }
  if [Standard-Mode/Definiens] {
    "means "; apply [Standard-Mode[1]];
  }
  if [Expandable-Mode] {
    apply [Expandable-Mode[1]]; ";"; "\n";
  }
}

tpl [Item[@kind='Predicate-Definition']] {
  if [Redefine] {
    "redefine ";
  }
  "pred ";
  if [Predicate-Pattern] {
    apply [Predicate-Pattern[1]]; "\n";
  } else {
    die (#message = "Predicate-Definition element lacks a Predicate-Pattern child!");
  }
  if [Definiens] {
    "means"; "\n";
    apply [Definiens[1]]; "\n"; ";";
  } else {
    ";"; "\n";
  }
}

tpl [Item[@kind='Functor-Definition']] {
  if [Redefine] {
    "redefine ";
  }
  "func ";
  if [Operation-Functor-Pattern | Bracket-Functor-Pattern] {
    apply [(Operation-Functor-Pattern | Bracket-Functor-Pattern)[1]]; // always exists?
  } else {
    die (#message = "Functor-Definition lacks both an Operation-Functor-Pattern child and a Bracket-Functor-Pattern child!");
  }
  
  if [Type-Specification] {
    " -> "; apply [Type-Specification[1]];
    if [No-Definiens] { // lol
      ";";
    }
  }

  "\n";

  if [Equals] {
    apply [Equals[1]]; "\n";
    if [Definiens] {
      apply [Definiens[1]]; ";";
    } else {
      die (#message = "Functor-Definition defined by an equation lacks a Definiens child!");
    }
  }

  if [Means] {
    apply [Means[1]]; "\n";
    if [Definiens] {
      apply [Definiens[1]]; ";";
    } else {
      die (#message = "Functor-Definition defined by a formula lacks a Definiens child!");
    }
  }

  "\n";

}

tpl [Predicate-Pattern] {
  if [@spelling] {
    if [Loci[2]] {
      apply [Loci[1]];
      " ";  `@spelling`;  " ";
      apply [Loci[2]];
    } else {
      die (#message = "Predicate-Pattern does not have two Loci children!");
    }
  } else {
    die (#message = "Predicate-Pattern lacks a spelling attribute!");
  }
}

tpl [Mode-Pattern] {
  if [@spelling] {
    `@spelling`;
    if [Loci] {
      if [Loci/*[1]] {
        " of "; apply [Loci[1]];
      }
    }
  } else {
    die (#message = "Predicate-Pattern lacks a spelling attribute!");
  }
}

tpl [Operation-Functor-Pattern] {
  if [@spelling] {
    // If either the first or the second Loci children have multiple
    // arguments, put parentheses around them.
    //
    // This should probably be simply a parameter of the Loci template.
    if [Loci[2]] {
      if [Loci[1]/*[2]] {
        apply [Loci[1]](#parentheses = "1");
      } else {
        apply [Loci[1]];
      }
      if [Loci[1]/*[1]] {
         " ";
       }
       `@spelling`;
      if [Loci[2]/*[1]] {
         " ";
       }
      if [Loci[2]/*[2]] {
        apply [Loci[2]](#parentheses = "1");
      } else {
        apply [Loci[2]];
      }
    } else {
      die (#message = "Operation-Functor-Pattern lacks two Loci children!");
    }
  } else {
    die (#message = "Operation-Functor-Pattern lacks a spelling!");
  }
}

tpl [Block[@kind='Definitional-Block']] {
  "definition";
  "\n";
  apply [*];
  "end";
  ";";
  "\n";
}

tpl [Block[@kind='Registration-Block']] {
  "registration";
  "\n";
  apply [*];
  "end"; ";"; "\n";
}

tpl [Item[@kind='Cluster']] {
  apply [*[1]]; // should be just one child, right?
}

tpl [Existence] {
  "existence";
}

tpl [Uniqueness] {
  "uniqueness";
}

tpl [Coherence] {
  "coherence";
}

tpl [Block[@kind='Proof']] {
  "proof"; "\n";
  apply [*];
  "end"; ";"; "\n";
}

tpl [Compatibility] {
  "compatibility";
}

tpl [Consistency] {
  "consistency";
}

tpl [Item[@kind='Correctness-Condition']] {
  apply [*[1]]; // I guess there's always at least one child
  if [Block[@kind='Proof']] {
    "\n";
    apply [Block[@kind='Proof'][1]];
  } else {
    if [Straightforward-Justification] {
      apply [Straightforward-Justification[1]]; ";"; "\n";
    } else {
      ";"; "\n";
    }
  }
}

tpl [Adjective] {
  if [@spelling] {
    if [Negated] {
      "non ";
      if [*[3]] {
         "("; list (#separ = ",", #elems = `*[position() > 1]`); ")";
      } else {
         apply [*[2]];
      }
    } else {
      if [*[2]] {
         "("; list (#separ = ",", #elems = `*`); ")";
      } else {
        apply [*[1]];
      }
    }
    `@spelling`;
  } else {
    die (#message = "Adjective lacks a spelling attribute!");
  }
}

tpl [Adjective-Cluster] {
  list (#separ = " ", #elems = `Adjective`);
}

tpl [Existential-Registration] {
  "cluster ";
  apply [Adjective-Cluster[1]]; // always exists, right?
  " for ";
  apply [Standard-Type[1]]; // is it always a Standard-Type element?
  ";"; "\n";
}

tpl [Functorial-Registration] {
  "cluster ";
  if [*[1]] {
    apply [*[1]];
    " -> ";
    if [Adjective-Cluster] {
      apply [Adjective-Cluster[1]]; ";"; "\n";
    } else {
      die (#message = "Functorial-Registation lacks an Adjective-Cluster child!");
    }
  } else {
    die (#message = "Functorial-Registration lacks a child!");
  }
}

tpl [Conditional-Registration] {
  "cluster ";
  if [Adjective-Cluster[2]] {
    apply [Adjective-Cluster[1]];
    " -> ";
    apply [Adjective-Cluster[2]];
    " for ";
    apply [*[3]]; // this is the type, hopefully
    ";"; "\n";
  } else {
    die (#message = "Conditional-Registration lacks two Adjective-Cluster children!");
  }
}

tpl [Item[@kind='Loci-Declaration']] {
  "let "; apply [*]; ";"; "\n";
}

tpl [Formula-Expression] {
  // ???
}

tpl [Definiens] {
  if [Label] {
    ":"; // special case: labels of definiens look like :this:, not like this:
    apply [Label[1]];
    " ";
    if [Partial-Definiens] {
      apply [Partial-Definiens[1]]; // could there be more than one?
      " otherwise ";
      apply [*[position() > 2]];
    } else {
      apply [*[position() > 1]];
    }
  } else {
    apply [*];
  }
}

tpl [Partial-Definiens] {
  apply [*[2]]; " if "; apply [*[3]]; // hmm...
}

tpl [Qualifying-Formula] {
  if [Simple-Term | Infix-Term | Circumfix-Term | Placeholder-Term] {
    apply [(Simple-Term | Infix-Term | Circumfix-Term | Placeholder-Term)[1]];
    " is ";
    if [Standard-Type] {
      apply [Standard-Type[1]];
    } else {
      die (#message = "Qualifying-Formula lacks a Standard-Type child!");
    }
  } else {
    die (#message = "Qualifying-Formula lacks a Simple-Term child and an Infix-Term and a Circumfix-Term and a Placeholder-Term child!");
  }
}

tpl [Negated-Formula] {
  "("; "not "; apply [*[1]]; ")";
}

tpl [Item[@kind='Attribute-Definition']] {
  if [Redefine] {
    "redefine ";
  }
  "attr ";
  apply [Attribute-Pattern[1]]; // is this always present?
  if [Definiens] {
    "\n";
    "means";
    "\n";
    apply [Definiens[1]]; ";"; "\n";
  } else {
    die (#message = "Attribute-Definition item lacks a Definiens child!");
  }
}

tpl [Loci](#parentheses) {
  if [Locus] {

    if [$parentheses = '1'] {
      "(";
    }
 
    list (#separ = ",", #elems = `Locus`);

    if [$parentheses = '1'] {
      ")";
    }

  }
}

tpl [Locus] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Locus lacks a spelling attribute!");
  }
}

tpl [Attribute-Pattern] {
  if [@spelling] {
    apply [Locus[1]];
    " is ";
    apply [Loci[1]];
    `@spelling`;
  } else {
    die (#message = "Attribute-Pattern lacks a spelling attribute!");
  }
}

tpl [Type-List] {
  list (#separ = ",", #elems = `Standard-Type | Clustered-Type`);
}

tpl [Functor-Segment] {
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
    if [Type-List] {
      "("; apply [Type-List[1]]; ")";
      " -> ";
      if [Standard-Type | Clustered-Type] {
        apply [(Standard-Type | Clustered-Type)[1]];
      } else {
        die (#message = "Standard-Type and Clustered-Type child missing from Functor-Segment element!");
      }
    } else {
      die (#message = "Type-List child of Functor-Segment is missing!");
    }
  } else {
    die (#message = "Variable child missing from Functor-Segment element!");
  }
}

tpl [Predicate-Segment] {
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
    if [Type-List] {
      "["; apply [Type-List[1]]; "]";
    } else {
      die (#message = "Type-List child of Predicate-Segment is missing!");
    }
  } else {
    die (#message = "Variable child missing from Predicate-Segment element!");
  }
}

tpl [Scheme] {
  if [@spelling] {
    "scheme "; `@spelling`;
  } else {
    die (#message = "Scheme lacks a spelling attribute!");
  }
}

tpl [Implicitly-Qualified-Segment] {
  // sanity check: at least one variable
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
  } else {
    die (#message = "Implicitly-Qualified-Segment lacks a Variable child!");
  }
}

tpl [Explicitly-Qualified-Segment](#verb) {
  // sanity check: at least one variable
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
    " ";
    if [$verb = ""] {
      "being";
    } else {
      $verb;
    }
    " ";
    apply [Standard-Type | Clustered-Type]; // should be Standard-Type or Clustered-Type
  } else {
    die (#message = "Explicitly-Qualified-Segment lacks a Variable child!");
  }
}

tpl [Existential-Quantifier-Formula] {
  "("; "ex "; apply [*[1]]; " st "; apply [*[2]]; ")";
}

tpl [Simple-Term] {
  // sanity check: there is a spelling
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Simple-Term lacks a spelling!");
  }
}

tpl [Arguments] {
  list (#separ = ",", #elems = `*`);
}

tpl [Private-Functor-Term] {
  if [@spelling] {
    `@spelling`;
    "(";
    list (#separ = ",", #elems = `./*`);
    ")";
  } else {
    die (#message = "Pivate-Functor-Term lacks a spelling!");
  }
}

tpl [Contradiction] {
  "contradiction";
}

tpl [Global-Choice-Term] {
  "the ";
  apply [*[1]];
}

tpl [Clustered-Type] {
  if [Adjective-Cluster] {
    apply [Adjective-Cluster[1]]; // adjectives
    " ";
    apply [*[2]]; // the type that the adjectives modity
  } else {
    die (#message = "Clustered-Type lacks an Adjective-Cluster child!");
  }
}

tpl [Item[@kind='Constant-Definition']] {
  "set ";
  apply [Variable[1]]; // only one, right?
  " = ";
  apply [*[2]];
  ";"; "\n";
}

tpl [Item[@kind='Private-Functor-Definition']] {
  if [Variable] {
    "deffunc ";  apply [Variable[1]];
    if [Type-List] {
      if [Type-List/*[1]] {
        "("; list (#separ = ",", #elems = `Type-List/*`); ")";
      }
    }
    " = "; apply [*[3]]; ";"; "\n"; // doesn't feel safe to me
  } else {
    die (#message = "Don't know how to deal with a Private-Functor-Definition that lacks a Variable child!");
  }
}

tpl [Item[@kind='Private-Predicate-Definition']] {
  if [Variable] {
    if [Variable[2]] {
      die (#message = "Private-Predicate-Definition has multiple variables!");
    } else {
      "defpred ";
      apply [Variable[1]];
      // sanity check: Type-List is present
      if [Type-List] {
        if [Type-List[2]] {
          die (#message = "Private-Predicate-Definition has multiple Type-List children!");
        } else {
          "[";
          list(#separ = ",", #elems = `Type-List[1]/*`);
          "]";
	  " means ";
	  apply [*[3]];
	  ";";
          "\n";
        }
      } else {
        die (#message = "Private-Predicate-Definition lacks a Type-List child!");
      }
    }
  } else {
    die (#message = "Private-Predicate-Definition item lacks a Variable child!");
  }
}

tpl [Theorem-Reference] {
  if [@spelling] {
    if [@number] {
      `@spelling`; ":"; `@number`;
    } else {
      die (#message = "Theorem-Reference lacks a number attribute!");
    }
  } else {
    die (#message = "Theorem-Reference lacks a spelling attribute!");
  }
}

tpl [Definition-Reference] {
  if [@spelling] {
    // do nothing: this is a sanity check
  } else {
    die (#message = "Definition-Reference lacks a spelling attribute!");
  }

  if [@number] {
    // do nothing: this is a sanity check
  } else {
    die (#message = "Definition-Reference lacks a number attribute!");
  }

  `@spelling`; ":def "; `@number`;
}

tpl [Item[@kind='Exemplification']] {
  "take ";
  if [*[2]] {  // take X = Y
    apply [*[1]]; " = "; apply [*[2]];
  } else {
    apply [*[1]];
  }
  ";";
  "\n";
}

tpl [Item[@kind='Generalization']] { // very ugly.  I've asked Czeslaw to refactor
  "let "; list (#separ = ",", #elems = `*`);
  // look at the following sibling
  // if [following-sibling::Item[@kind='Assumption']/Collective-Assumption] {
  //   " such that"; "\n";
  //   list (#separ = "\nand\n",
  //         #elems = `following-sibling::Item[@kind='Assumption']/Collective-Assumption/Proposition`);
  // }
  ";"; "\n";
}

tpl [Private-Predicate-Formula] {
  if [@spelling] {
    `@spelling`;
    "[";
    list (#separ = ",", #elems = `*`);
    "]";
  } else {
    die (#message = "Private-Predicate-Formula lacks a spelling!");
  }
}

tpl [Conjunctive-Formula] {
  "("; apply [*[1]]; " & "; apply [*[2]]; ")";
}

tpl [Disjunctive-Formula] {
  "("; apply [*[1]]; " or "; apply [*[2]]; ")";
}

tpl [Conditional-Formula] {
  "("; apply [*[1]]; " implies "; apply [*[2]]; ")";
}

tpl [Biconditional-Formula] {
  "("; apply [*[1]]; " iff "; apply [*[2]]; ")";
}

tpl [Placeholder-Term] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Placeholder-Term lacks a spelling attribute!");
  }
}

tpl [Attributive-Formula] {
  apply [*[1]]; " is "; apply [*[2]];
}

tpl [Predicative-Formula] {
  // sanity check: there's a spelling
  if [@spelling] {
    apply [Arguments[1]];
    " "; `@spelling`; " ";
    apply [Arguments[2]];
  } else {
    die (#message = "Predicative-Formula lacks a spelling!");
  }
}

// first stab at abstracting treatment of quantified formulas not sure
// if this applies in all cases.  Need to grab the explicitly
// qualified segment.
tpl quantified-formula(#kind) {

  // sanity check: there is one and only one explicitly qualified segment
  if [Explicitly-Qualified-Segment] {
    if [Explicitly-Qualified-Segment[2]] {
      die (#message = "Universal-Quantifier-Formula has multiple Explicitly-Qualified-Segment children!");
    } else {
      if [$kind = "forall"] { "for "; } else { "ex"; }
      apply [Explicitly-Qualified-Segment[1]];
      " holds ";
      "(";
      apply [*[2]]; // weird, definitely not right
      ")";
    }
  } else {
    die (#message = "Universal-Quantifier-Formula lacks an Explicitly-Qualified-Segment child!");
  }
}

tpl [Compact-Statement] {
  // nothing?
}

tpl [Thesis] {
  "thesis";
}

tpl [Item[@kind='PropertyRegistration']] { // shouldn't this be "Property-Registration", for parallelism?
  apply [*[1]]; // property
  " of ";
  apply [*[2]];
  if [*[3]] {  // justification for the property registration
    "\n";
    apply [*[3]];
  } else {
    ";"; "\n";
  }
}

tpl [Item[@kind='Property']] {
  if [*[1]] {
    apply [*[1]];
    if [*[2]] {
      if [Block[@kind='Proof']] {
        "\n";
        apply [Block[@kind='Proof'][1]];
      } else {
        apply [*[2]]; ";"; "\n";
      }

    } else {
      die (#message = "Property Item has only one child!");
    }
  } else {
    die (#message = "Property Item has no children!");
  }
}

tpl [Item[@kind="Correctness"]] {
  "correctness"; ";"; "\n";
}

tpl [Proposition] {
  if [Label] {
    apply [Label[1]];
    " ";
    apply [*[2]];
  } else {
    apply [*[1]]; // no label case
  }
}

tpl [Label] {
  if [@spelling] {
    `@spelling`; ":";
  } else {
    die (#message = "Label element lacks a spelling attribute!");
  }
}

tpl [Local-Reference] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Local-Reference element lacks a spelling attribute!");
  }
}

tpl [Scheme-Justification] {
  if [@spelling and @idnr and @nr] {
    " from "; `@spelling`;
    if [@nr > "0"] {
      ":sch "; `@idnr`;
    }
    if [*[1]] { // there are scheme arguments
    "("; list (#separ = ",", #elems = `*`); ")";
    }
  } else {
    die (#message = "Scheme-Justification lacks either a spelling or an idnr attribute!");
  }

}

tpl [Infix-Term] {
  if [@spelling] {
    // do nothing: this is just a sanity check
  } else {
    die (#message = "Infix-Term lacks a spelling!");
  }

  if [Arguments[2]] {
  } else {
    die (#message = "Infix-Term lacks two Arguments children!");
  }

  "(";

  if [Arguments[1]/*[1]] {
    if [Arguments[1]/*[2]] {
      "("; list (#separ = ",", #elems = `Arguments[1]/*`); ")";
    } else {
      apply [Arguments[1]/*[1]];
    }
    " ";
  }

  `@spelling`;

  if [Arguments[2]/*[1]] {
    " ";
    if [Arguments[2]/*[2]] {
      "("; list (#separ = ",", #elems = `Arguments[2]/*`); ")";
    } else {
      apply [Arguments[2]/*[1]];
    }
  }

  ")";
}

tpl [Bracket-Functor-Pattern] {
  if [@spelling] {
    if [Right-Circumflex-Symbol] {
      if [Loci] {
        `@spelling`;
         list (#separ = ",", #elems = `Loci/Locus`);
         apply [Right-Circumflex-Symbol[1]];
      } else {
        die (#message = "Bracket-Functor-Pattern lacks a Loci child!");
      }
    } else {
      die (#message = "Bracket-Functor-Pattern lacks a Right-Circumflex-Symbol child!");
    }
  } else {
    die (#message = "Bracket-Functor-Pattern lacks a spelling!");
  }
}

tpl [Circumfix-Term] {
  if [@spelling] {
    // do nothing: this is just a sanity check
  } else {
    die (#message = "Circumfix-Term lacks a spelling attribute!");
  }

  if [Right-Circumflex-Symbol] {
    // do nothing: this is just a sanity check
  } else {
    die (#message = "Circumfix-Term lacks a right-Circumflex-Symbol child!");
  }

  `@spelling`;
  list (#separ = ",", #elems = `*[position() > 1]`); // everything after the Right-Circumflex-Symbol
  apply [Right-Circumflex-Symbol[1]];
}

tpl [Right-Circumflex-Symbol] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Right-Circumflex-Symbol lacks a spelling attribute!");
  }
}

tpl [Qualification-Term] {
  "("; apply [*[1]]; " qua "; apply [*[2]]; ")";
}

tpl [Item[@kind='Choice-Statement']] {
  if [Straightforward-Justification/Link] {
    "then ";
  }
  "consider ";
  list (#separ = ",", #elems = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`);
  if [Proposition] {
    " such that ";
    list (#separ = " and ", #elems = `Proposition`);
    if [Scheme-Justification] {
      apply [Scheme-Justification[1]];
    }
    if [Straightforward-Justification] {
      apply [Straightforward-Justification[1]];
    }
  }
  ";";
  "\n";
}

tpl [Straightforward-Justification] {
  if [Link] {
    // already taken care of in the template for whatever element
    // contains this one
    if [*[2]] {
      " by ";
      list (#separ = ",", #elems = `*[position() > 1]`);
    }
  } else {
    if [*[1]] {
      " by ";
      list (#separ = ",", #elems = `*`);
    } 
  }
}

// Constructor properties

tpl [Projectivity] {
  "projectivity";
}

tpl [Involutiveness] {
  "involutiveness";
}

tpl [Idempotence] {
  "idempotence";
}

tpl [Commutativity] {
  "commutativity";
}

tpl [Reflexivity] {
  "reflexivity";
}

tpl [Irreflexivity] {
  "irreflexivity";
}

tpl [Symmetry] {
  "symmetry";
}

tpl [Asymmetry] {
  "asymmetry";
}

tpl [Connectedness] {
  "connectedness";
}

tpl [Sethood] {
  "sethood";
}

tpl [Compact-Statement] {
  // do nothing.  This element simply indicates what kind of thing its
  // parent is.  It should probably be represented as an atribute of
  // the parent; or the parent element itself could be something
  // different.
}

tpl [Single-Assumption] {
  if [Proposition] {
    apply [Proposition[1]];
  } else {
    die (#message = "Single-Assumption element lacks a Proposition child!");
  }
}

tpl [Item[@kind='Assumption']] {
  if [Single-Assumption] {
    "assume "; apply [Single-Assumption]; ";"; "\n";
  }
  if [Collective-Assumption] {
    apply [Collective-Assumption[1]];
  }
}

tpl [Iterative-Step] {
  if [Infix-Term | Simple-Term | Circumfix-Term] {
    apply[(Infix-Term | Simple-Term | Circumfix-Term)[1]];
    if [Straightforward-Justification] {
      apply [Straightforward-Justification[1]];
    }
    if [Scheme-Justification] {
      apply [Scheme-Justification[1]];
    }
    // there might be no justification; in that case, do nothing
  } else {
    die (#message = "Don't know how to deal with an Iterative-Step that lacks an Infix-Term child, a Simple-Term child, and a Circumfix-Term child!");
  }
}

tpl [Collective-Assumption] {
  "assume that"; "\n";
  list (#separ = "\nand\n", #elems = `Proposition`); ";"; "\n";
}

tpl [Item[@kind='Existential-Assumption']] {
  if [Implicitly-Qualified-Segment | Explicitly-Qualified-Segment] {
    "given ";
    list (#separ = ",", #elems = `Implicitly-Qualified-Segment | Explicitly-Qualified-Segment`);
    if [Proposition] {
      " such that"; "\n";
      list (#separ = "\nand\n", #elems = `Proposition`); ";"; "\n";
      if [Scheme-Justification] {
        apply [Scheme-Justification[1]];
      }
      if [Straightforward-Justification] {
        apply [Straightforward-Justification[1]];
      }
      "\n";
    } else {
      die (#message = "Existential-Assumption element lacks a Proposition child!");
    }
  } else {
    die (#message = "Existential-Assumption item lacks an Implicitly-QualifiedSegment child and an Explicitly-Qualified-Segment child!");
  }
}

tpl [Item[@kind='Conclusion']] {

  if [Iterative-Equality] {
    if [Proposition] {
      if [Straightforward-Justification] {
        if [Straightforward-Justification/Link] {
          "hence ";
        } else {
          "thus ";
        }
        apply [Proposition[1]];
        apply [Straightforward-Justification[1]];
      }
      if [Scheme-Justification] {
        if [Scheme-Justification/Link] {
          "hence ";
        } else {
          "thus ";
        }
        apply [Proposition[1]];
        apply [Scheme-Justification[1]];
      }
      "\n";
      ".= "; list (#separ = "\n.= ", #elems = `Iterative-Step`); ";"; "\n";
    } else {
      die (#message = "Don't know how to deal with a Conclusion item representing an iterative equality that lacks a Proposition child!");
    }
  } else {
    if [Diffuse-Statement] {
      apply [Block[1]];
    } else {
      if [Scheme-Justification] {
        "thus ";
        apply [Proposition[1]];
        apply [Scheme-Justification[1]]; ";"; "\n";
      } else {
        if [Straightforward-Justification/Link] { // hence
          "hence ";
          apply [Proposition[1]];
          apply [Straightforward-Justification[1]];
          ";";
          "\n";
        } else {
          "thus ";
          if [Straightforward-Justification] {
            apply [Proposition[1]];
            " ";
            apply [Straightforward-Justification[1]];
            ";";
            "\n";
          } else {
            if [Block[@kind='Proof']] {
              apply [Proposition[1]]; "\n";
              apply [Block[@kind='Proof'][1]];
            } else {
              die (#message = "Don't know how to handle Item of kind Conclusion: it lacks s a Straightforward-Justification child, and it lacks a Proof block!");
            }
          }
        }
      }
    }
  }
}

tpl [Item[@kind='Mode-Synonym']] {
  if [Mode-Pattern[2]] {
    "synonym ";
     apply [Mode-Pattern[2]]; " for ";
     apply [Mode-Pattern[1]]; ";"; "\n"; // aren't these backwards?
  } else {
    die (#message = "Mode-Synonym item missing two Mode-Pattern children!");
  }
}

tpl [Item[@kind='Func-Synonym']] {
  if [Operation-Functor-Pattern[2]] {
    "synonym ";
     apply [Operation-Functor-Pattern[2]]; " for ";
     apply [Operation-Functor-Pattern[1]]; ";"; "\n"; // aren't these backwards?
  } else {
    die (#message = "Func-Synonym item missing two Operation-Functor-Pattern children!");
  }
}

tpl [Item[@kind='Attr-Antonym']] {
  if [Attribute-Pattern[2]] {
    "antonym ";
     apply [Attribute-Pattern[2]]; " for ";
     apply [Attribute-Pattern[1]]; ";"; "\n"; // aren't these backwards?
  } else {
    die (#message = "Attr-Antonym item missing two Attribute-Pattern children!");
  }
}

tpl [Item[@kind='Pred-Antonym']] {
  if [Predicate-Pattern[2]] {
    "antonym ";
     apply [Predicate-Pattern[2]]; " for ";
     apply [Predicate-Pattern[1]]; ";"; "\n"; // aren't these backwards?
  } else {
    die (#message = "Pred-Antonym item missing two Predicate-Pattern children!");
  }
}

tpl [Block[@kind='Notation-Block']] {
  "notation"; "\n";
  if [Item[@kind='Loci-Declaration']] {
    apply [Item[@kind="Loci-Declaration"][1]];
    apply [Item[position() > 1]]; // bad form...
  } else {
    apply [*];
  }
  "end;"; "\n";
}

tpl [Item[@kind='Theorem-Item']] {
  "theorem"; "\n";
  if [Proposition] {
    apply [Proposition[1]];
    if [Block[@kind='Proof']] {
      "\n";
      apply [Block[@kind='Proof'][1]];
    } else {
      if [Straightforward-Justification] {
        apply [Straightforward-Justification[1]]; ";"; "\n";
      } else {
        die (#message = "Don't know how to deal with a Theorem-Item element that lacks both a Proof block child and a Straightforward-Justification child");
      }
    }
  } else {
    die (#message = "Theorem-Item lacks a Proposition child!");
  }
}

tpl [Block[@kind='Now-Reasoning']] {
  "now"; "\n";
  apply [*];
  "end;"; "\n";
}

tpl [Block[@kind='Hereby-Reasoning']] {
  "hereby"; "\n";
  apply [*];
  "end;"; "\n";
}

tpl [Item[@kind='Type-Changing-Statement']] {
  if [Straightforward-Justification/Link | Scheme-Justification/Link] {
    "then ";
  }
  "reconsider ";
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
  } else {
    if [Equality] {
      apply [Equality[1]];
    } else {
      die (#message = "Don't know how to deal with a Type-Changing-Statement that lacks both a Variable and an Equality child!");
    }
  }
  if [Standard-Type | Clustered-Type] {
    " as "; apply [(Standard-Type | Clustered-Type)[1]];
    if [Straightforward-Justification] {
      apply [Straightforward-Justification[1]];
    }
    ";"; "\n";
  } else {
    die (#message = "Don't know how to deal with a Type-Changing-Statement element that lacks a Standard-Type child!");
  }
}

tpl [Equality] {
  apply [*[1]]; " = "; apply [*[2]];
}

tpl [Item[@kind='Regular-Statement']] {
  if [Straightforward-Justification/Link | Scheme-Justification/Link] {
    "then ";
  }
  if [Iterative-Equality] {
    if [Proposition] {
      apply [Proposition[1]];
      if [Straightforward-Justification] {
        apply [Straightforward-Justification[1]];
      }
      if [Scheme-Justification] {
        apply [Scheme-Justification[1]];
      }
      "\n";
      ".= "; list (#separ = "\n.= ", #elems = `Iterative-Step`); ";"; "\n";
    } else {
      die (#message = "Don't know how to deal with a Regular-Statement item representing an iterative equality that lacks a Proposition child!");
    }
  } else {
    if [Diffuse-Statement] {
      if [Label] {
        apply [Label[1]];
      }
      if [Block[@kind='Now-Reasoning']] {
        apply [Block[@kind='Now-Reasoning'][1]];
      } else {
        if [Block[@kind='Hereby-Reasoning']] {
          apply [Block[@kind='Hereby-Reasoning'][1]];
        } else {
          die (#message = "Don't know how to handle this piece of diffuse reasoning it is neither a 'now' nor a 'hereby' block.");
        }
      }
    } else {
        if [Proposition] {
          apply [Proposition[1]];
        } else {
          die (#message = "Item of kind Regular-Statement lacks a Proposition child!");
        }
      
        if [Straightforward-Justification] {
          " "; apply [Straightforward-Justification[1]]; ";"; "\n";
        }
        if [Scheme-Justification] {
          " "; apply [Scheme-Justification[1]]; ";"; "\n";
        }
        if [Block[@kind='Proof']] {
          "\n";
          apply [Block[@kind='Proof'][1]];
        } 
      }
  }
}

// dumb: this just is a copy-and-paste-and-edit of the
// Existential-Quantifier-Formula case.  Should be parameterized and
// combined into one.
tpl [Universal-Quantifier-Formula] {
  "("; "for "; apply [*[1]]; " holds "; apply [*[2]]; ")";
}

tpl [Schematic-Variables] {
  list (#separ = ",", #elems = `Functor-Segment | Predicate-Segment`);
}

tpl [Provisional-Formulas] {
  if [*[1]] { // there's something to do
    list (#separ = "\nand\n", #elems = `*`);
  }
}

tpl [Item[@kind='Scheme-Head']] {

  // sanity check: one and only one Scheme child
  if [Scheme] {
    if [Scheme[2]] {
      die (#message = "More than one Scheme child of a Scheme-Head element!");
    } else {
      apply [Scheme[1]];
      " { ";
      apply [Schematic-Variables[1]];
      " } : ";
      apply [*[3]]; // the scheme formula
      if [Provisional-Formulas] {
        "\n"; "provided"; "\n";
        apply [Provisional-Formulas[1]];
      }
    }
  } else {
    die (#message = "Scheme child of a Scheme-Head item is missing!");
  }
}
