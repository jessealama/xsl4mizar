stylesheet 1.0;
output method=text;

// List utilities.  Stolen from Josef.  Thanks, Josef.

tpl list(#separ,#elems) { 
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { copy-of $separ; } }
}

key "D_G" [Symbol[@kind='G']] `@nr`;
key "D_K" [Symbol[@kind='K']] `@nr`;
key "D_J" [Symbol[@kind='J']] `@nr`;
key "D_L" [Symbol[@kind='L']] `@nr`;
key "D_M" [Symbol[@kind='M']] `@nr`;
key "D_O" [Symbol[@kind='O']] `@nr`;
key "D_R" [Symbol[@kind='R']] `@nr`;
key "D_U" [Symbol[@kind='U']] `@nr`;
key "D_V" [Symbol[@kind='V']] `@nr`;
// identifiers
key "D_I" [Symbol[@kind='I']] `@nr`;

$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; } 

// name of current article (upper case)
#aname= { `string(/*/@articleid)`; }

// name of current article (lower case)
#anamelc= { `translate($aname, $ucletters, $lcletters)`; }

// .idx file with identifier names
#ids=  { `concat($anamelc, '.idx')`; }

tpl get_vid_name(#vid)
{
  for-each [document($ids, /)] 
  { 
     for-each [key('D_I', $vid)] { `@name`; }
  }
}

tpl die(#message) {
  msg terminate="yes" $message;
}

tpl [Text-Proper] {
  for-each [Item] {
    apply [.];
  }
}

tpl [Variable] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Variable missing a spelling!");
  }
}

tpl [Standard-Type] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Standard-Type lacks a spelling!");
  }
}

tpl [Item[@kind='Reservation']] {
  "reserve ";
  list (#separ = ",", #elems = `Variable`);
  " ";
  "for ";

  // sanity check: one and only one type
  if [Standard-Type] {
    if [Standard-Type[2]] {
      die (#message = "Multiple Standard-Type children of a Reservation item!");
    } else {
      apply [Standard-Type[1]]; ";"; "\n";
    }
  } else {
    die(#message="No type was found under a Reservation!");
  }
}

tpl [Item[@kind='Section-Pragmma']] {
  "begin"; "\n";
}

tpl [Item[@kind='Scheme-Block-Item']] {

  // sanity check: there is one and only one Scheme-Block child
  if [Block[@kind='Scheme-Block']] {
    if [Block[@kind='Scheme-Block'][2]] {
      die(#message = "Multiple Scheme-Block children of a Scheme-Block-Item!");
    } else {
      apply[Block[@kind='Scheme-Block'][1]];
    }
  } else {
    die(#message = "Scheme-Block child of a Scheme-Block-Item is missing!");
  }
}

tpl [Block[@kind='Scheme-Block']] {

  // sanity check: there is one and only one Scheme-Head child
  if [Item[@kind='Scheme-Head']] {
    if [Item[@kind='Scheme-Head'][2]] {
      die(#message = "Multiple Scheme-Head children of a Scheme-Block!");
    } else {
      apply [Item[@kind='Scheme-Head'][1]];
      if [*[2]] { // I guess this is the proof
        "\n";
        "proof";
        "\n";
        apply [*[position() > 2]];
        "end";
	";";
	"\n";
      }
    }
  } else {
    die(#message = "Scheme-Head child of Scheme-Block is missing!");
  }
}

tpl [Item[@kind='Definition-Item']] {
  apply [*[1]];
}

tpl [Block[@kind='Definitional-Block']] {
  "definition";
  "\n";
  apply [*];
  "end";
  ";";
  "\n";
}

tpl [Block[@kind='Registration-Block']] {
  "registration";
  "\n";
  apply [*];
  "end"; ";"; "\n";
}

tpl [Item[@kind='Cluster']] {
  apply [*[1]]; // should be just one child, right?
}

tpl [existence] { // I guess it should be "Existence"
  "existence";
}

tpl [Item[@kind='Correctness-Condition']] {
  apply [*[1]]; // I guess there's always at least one child
  if [Block[@kind='Proof']] {
    "\n";
    apply [Block[@kind='Proof'][1]];
  } else {
    ";"; "\n";
  }
}

tpl [Adjective] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Adjective lacks a spelling attribute!");
  }
}

tpl [Adjective-Cluster] {
  "cluster ";
  list (#separ = "WEIRD", #elems = `Adjective`); // don't know how to deal with multiple adjectives
}

tpl [Existential-Registration] {
  apply [Adjective-Cluster[1]]; // always exists, right?
  " for ";
  apply [Standard-Type[1]]; // is it always a Standard-Type element?
  ";"; "\n";
}

tpl [Item[@kind='Loci-Decraration']] { // should be Declaration
  "let "; apply [*]; ";"; "\n";
}

tpl [Formula-Expression] {
  // ???
}

tpl [Definiens] {
  if [Label] {
    ":"; // special case: labels of definiens look like :this:, not like this:
    apply [Label[1]];
    " ";
    apply [*[3]]; // hacktastic
  } else {
    apply [*[2]]; // probably not correct...
  }
}

tpl [Negated-Formula] {
  "not ";
  apply [*[1]]; // assuming there's just one child
}

tpl [Item[@kind='Attribute-Definition']] {
  "attr ";
  apply [Attribute-Pattern[1]]; // is this always present?
  if [Definiens] {
    "\n";
    "means";
    "\n";
    apply [Definiens[1]]; // is this always present?
    "\n";
  } else {
    // not sure what to do in this case
  }
}

tpl [Loci] {
  // ???
}

tpl [Locus] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Locus lacks a spelling attribute!");
  }
}

tpl [Attribute-Pattern] {
  if [@spelling] {
    apply [Locus];
    " is ";
    `@spelling`;
  } else {
    die (#message = "Attribute-Pattern lacks a spelling attribute!");
  }
}

tpl [Type-List] {
  "(";
  for-each [Standard-Type] {
   apply [.];
  }
  ")";
}

tpl [Functor-Segment] {

  // sanity check: there is one and only one Variable child
  if [Variable] {
    if [Variable[2]] {
      die (#message = "More than one Variable child of a Functor-Segment element!");
    } else {
      apply [Variable[1]];

      // sanity check: there is one and only one Type-List
      if [Type-List] {
        if [Type-List[2]] {
          die (#message = "Multiple Type-List children of a Functor-Segment!");
        } else {
          apply [Type-List[1]];
          " -> ";
          // sanity check: there is one and only one Standard-Type
          if [Standard-Type] {
            if [Standard-Type[2]] {
              die (#message = "Multiple Standard-Type children of a Functor-Segment element!");
            } else {
              apply [Standard-Type[1]];
            }
          } else {
            die (#message = "Standard-Type child missing from Functor-Segment element!");
          }
        }
      } else {
        die (#message = "Type-List child of Functor-Segment is missing!");
      }
    }
  } else {
    die (#message = "Variable child missing from Functor-Segment element!");
  }
}

tpl [Predicate-Segment] {
  // sanity check: there is one and only one Variable child
  if [Variable] {
    if [Variable[2]] {
      die (#message = "More than one Variable child of a Predicate-Segment element!");
    } else {
      apply [Variable[1]];

      // sanity check: there is one and only one Type-List
      if [Type-List] {
        if [Type-List[2]] {
          die (#message = "Multiple Type-List children of a Predicate-Segment!");
        } else {
          apply [Type-List[1]];
        }
      } else {
        die (#message = "Type-List child of Predicate-Segment is missing!");
      }
    }
  } else {
    die (#message = "Variable child missing from Predicate-Segment element!");
  }
}

tpl [Scheme] {
  if [@spelling] {
    "scheme "; `@spelling`;
  } else {
    die (#message = "Scheme lacks a spelling attribute!");
  }
}

tpl [Implicitly-Qualified-Segment] {
  // sanity check: at least one variable
  if [Variable] {
    list (#separ = ",", #elems = `Variable`);
  } else {
    die (#message = "Implicitly-Qualified-Segment lacks a Variable child!");
  }
}

tpl [Explicitly-Qualified-Segment] {
  // sanity check: at least one variable
  if [Variable] {
    // sanity check: there is a Standard-Type
    if [Standard-Type] {
      list (#separ = ",", #elems = `Variable`);
      " being ";
      apply [Standard-Type[1]];
    } else {
      die (#message = "Explicitly-Qualified-Segment lacks a Standard-Type child!");
    }
  } else {
    die (#message = "Explicitly-Qualified-Segment lacks a Variable child!");
  }
}

tpl [Existential-Quantifier-Formula] {
  "ex ";
  apply [*[1]]; // Implicitly-Qualified-Segment or Explicitly-Qualified-Segment; can there be more than one?
  " holds ";
  "(";
  apply [*[2]]; // weird, definitely not right
  ")";
}

tpl [Simple-Term] {
  // sanity check: there is a spelling
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Simple-Term lacks a spelling!");
  }
}

tpl [Arguments] {
  list (#separ = ",", #elems = `*`);
}

tpl [Private-Functor-Term] {
  if [@spelling] {
    `@spelling`;
    "(";
    list (#separ = ",", #elems = `./*`);
    ")";
  } else {
    die (#message = "Pivate-Functor-Term lacks a spelling!");
  }
}

tpl [Item[@kind='Private-Predicate-Definition']] {
  if [Variable] {
    if [Variable[2]] {
      die (#message = "Private-Predicate-Definition has multiple variables!");
    } else {
      "defpred ";
      apply [Variable[1]];
      // sanity check: Type-List is present
      if [Type-List] {
        if [Type-List[2]] {
          die (#message = "Private-Predicate-Definition has multiple Type-List children!");
        } else {
          "[";
          list(#separ = ",", #elems = `Type-List[1]/*`);
          "]";
	  " means ";
	  apply [*[3]];
	  ";";
        }
      } else {
        die (#message = "Private-Predicate-Definition lacks a Type-List child!");
      }
    }
  } else {
    die (#message = "Private-Predicate-Definition item lacks a Variable child!");
  }
}

tpl [Item[@kind='Exemplification']] {
  "take ";
  list (#separ = ",", #elems = `*`);
  ";";
  "\n";
}

tpl [Item[@kind='Generalization']] {
  "let ";
  list (#separ = ",", #elems = `*`);
  ";";
  "\n";
}

tpl [Private-Predicate-Formula] {
  if [@spelling] {
    `@spelling`;
    "(";
    list (#separ = ",", #elems = `*`);
    ")";
  } else {
    die (#message = "Private-Predicate-Formula lacks a spelling!");
  }
}

tpl [Conjunctive-Formula] {
  apply [*[1]];
  " & ";
  apply [*[2]];
}

tpl [Conditional-Formula] {
  apply [*[1]];
  " implies ";
  apply [*[2]];
}

tpl [Placeholder-Term] {
  if [@nr] {
    "$"; `@nr`;
  } else {
    die (#message = "Placeholder-Term lacks an NR attribute!");
  }
}

tpl [Predicative-Formula] {
  // sanity check: there's a spelling
  if [@spelling] {
    apply [Arguments[1]];
    " "; `@spelling`; " ";
    apply [Arguments[2]];
  } else {
    die (#message = "Predicative-Formula lacks a spelling!");
  }
}

tpl [Biconditional-Formula] {
  "(";
  apply [*[1]];
  " iff ";
  apply [*[2]];
  ")";
}

// first stab at abstracting treatment of quantified formulas not sure
// if this applies in all cases.  Need to grab the explicitly
// qualified segment.
tpl quantified-formula(#kind) {

  // sanity check: there is one and only one explicitly qualified segment
  if [Explicitly-Qualified-Segment] {
    if [Explicitly-Qualified-Segment[2]] {
      die (#message = "Universal-Quantifier-Formula has multiple Explicitly-Qualified-Segment children!");
    } else {
      if [$kind = "forall"] { "for "; } else { "ex"; }
      apply [Explicitly-Qualified-Segment[1]];
      " holds ";
      "(";
      apply [*[2]]; // weird, definitely not right
      ")";
    }
  } else {
    die (#message = "Universal-Quantifier-Formula lacks an Explicitly-Qualified-Segment child!");
  }
}

tpl [Compact-Statement] {
  // nothing?
}

tpl [thesis] { // probably should be "Thesis"
  "thesis";
}

tpl [Proposition] {
  if [Label] {
    apply [Label[1]];
    " ";
    apply [*[2]];
  } else {
    apply [*[1]]; // no label case
  }
}

tpl [Label] {
  if [@spelling] {
    `@spelling`; ":";
  } else {
    die (#message = "Label element lacks a spelling attribute!");
  }
}

tpl [Local-Reference] {
  if [@spelling] {
    `@spelling`;
  } else {
    die (#message = "Local-Reference element lacks a spelling attribute!");
  }
}

tpl [Scheme-Justification] {
  if [@nr] {
    " from BOGUS:sch "; `@nr`;
    "(";
    list (#separ = ",", #elems = `*`);
    ")";
  } else {
    die (#message = "Scheme-Justification lacks an nr attribute!");
  }

}

tpl [Item[@kind='Choice-Statement']] {
  "consider ";
  apply [*[1]]; // variables
  if [Proposition] {
    " such that ";
    apply [Proposition]; // could be more than one, right?
    if [Scheme-Justification] {
      apply [Scheme-Justification[1]];
    }
  }
  ";";
  "\n";
}

tpl [Straightforward-Justification] {
  if [*[1]] {
    " by ";
    apply [*];
  } else {
    // do nothing
  }
}

tpl [Item[@kind='Conclusion']] {
  if [Straightforward-Justification/Link] { // hence
    "hence "; apply [Proposition[1]];
  } else { // thus
    // not handled yet
  }
  ";";
  "\n";
}

tpl [Item[@kind='Regular-Statement']] {
  apply [Proposition[1]];
  apply [Straightforward-Justification[1]]; // is this always around?
  ";";
  "\n";
}

// dumb: this just is a copy-and-paste-and-edit of the
// Existential-Quantifier-Formula case.  Should be parameterized and
// combined into one.
tpl [Universal-Quantifier-Formula] {
  "for ";
  apply [*[1]]; // Implicitly-Qualified-Segment or Explicitly-Qualified-Segment
  " holds ";
  "(";
  apply [*[2]]; // matrix
  ")";
}

tpl [Schematic-Variables] {
  list (#separ = ",", #elems = `Functor-Segment | Predicate-Segment`);
}

tpl [Provisional-Formulas] {
  if [*[1]] { // there's something to do
    list (#separ = "\nand", #elems = `*`);
  }
}

tpl [Item[@kind='Scheme-Head']] {

  // sanity check: one and only one Scheme child
  if [Scheme] {
    if [Scheme[2]] {
      die (#message = "More than one Scheme child of a Scheme-Head element!");
    } else {
      apply [Scheme[1]];
      " { ";
      apply [Schematic-Variables[1]];
      " } : ";
      apply [*[3]]; // the scheme formula
      if [Provisional-Formulas] {
        apply [Provisional-Formulas[1]];
      }
    }
  } else {
    die (#message = "Scheme child of a Scheme-Head item is missing!");
  }
}

//   for-each [Block[@kind='Scheme-Block']] {
//     for-each [Item[@kind='Scheme-Head']] {
//       for-each [Scheme] {
//         "scheme "; get_vid_name (#vid = `@idnr`);
//       }
//       " { ";
//       // this seems suboptimal: we should treat possibly-interleaved
//       // functor and predicate segments
      
//       // functor segment
//       for-each [Functor-Segment] {
//         for-each [Variable] {
//           get_vid_name (#vid = `@idnr`);
//         }
//         for-each [Type-List] {
//           "not sure how to handle this ";
//         }
//         for-each [Standard-Type] {
//           "type "; `@idnr`;
//         }
//       }
//       // predicate segments
//       for-each [Predicate-Segment] {
//         for-each [Variable] {
//           get_vid_name (#vid = `@idnr`);
//         }
//         for-each [Type-List] {
//           "not sure how to handle this ";
//         }
//         for-each [Standard-Type] {
//           "type "; `@idnr`;
//         }
//       }
//       " : ";
//       " } ";
//     }
//   }
// }
