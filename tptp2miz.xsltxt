stylesheet "1.0";

output method=text;


// $Revision: 1.6 $
//
// File: mizpl.xsltxt - stylesheet translating TSTP XML solutions to MML Query DLI syntax
//
// Author: Josef Urban
//
// License: GPL (GNU GENERAL PUBLIC LICENSE)


// XSLTXT (https://xsltxt.dev.java.net/) stylesheet taking
// TSTP XML solutions to MML Query DLI syntax

// To produce standard XSLT from this do e.g.:
// java -jar xsltxt.jar toXSL tptp2miz.xsltxt >tptp2miz.xsl


strip-space "*";


$lcletters= { "abcdefghijklmnopqrstuvwxyz"; }
$ucletters= { "ABCDEFGHIJKLMNOPQRSTUVWXYZ"; }

tpl lc(#s) { `translate($s, $ucletters, $lcletters)`; }
tpl uc(#s) { `translate($s, $lcletters, $ucletters)`; }

// MML Query needs numbers for proper display of indeces,
// hence this poor-man's numberization of proof-levels
tpl usto0(#s) { `translate($s, "_", "0")`; }


tpl [/] {
  choose {
    when [not(tstp)] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it lacks a 'tstp' root element.";
    }
    when [tstp[2]] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it has multiple 'tstp' root elements.";
    }
    otherwise {
      apply [tstp];
    }
  }
}

tpl [tstp] {

  // give the type 'set' to all variables appearing in the problem
  for-each [descendant::variable[@name
                                 and not(@name = preceding::variable[@name]/@name)]] {
    apply [.] mode="set";
  }

  apply;
}

tpl [comment] {
  // don't know how to properly deal with this yet

  // ":: "; `text()`;
}

tpl [formula[not(@name)]] {
  msg terminate="yes" "We encountered a formula element that lacks a name attribute.";
}

tpl [formula[@name]] {
    `@name`; ": ";
    apply[*[1]]; ";\n";
}

tpl [variable[not(@name)]] {
  msg terminate="yes" "Error: unable to render a variable element that lacks a name attribute.";
}

tpl [variable[@name]] {
  `@name`;
}

tpl [variable[not(@name)]] mode="set" {
  msg terminate="yes" "Error: unable to assign the type 'set' to a variable that lacks a name";
}

tpl [variable[@name]] mode="set" {
  "reserve "; `@name`; " for set;\n";
}

tpl [quantifier[not(@type)]] {
  msg terminate="yes" "Error: we encountered a quantifier element that lacks a type attribute.";
}

tpl [quantifier[@type and not(@type = "universal" or @type = "existential")]] {
  $type = `@type`;
  $message = `concat ("Error: we encountered a quantifier element whose type, '", $type, "' is neither 'universal' nor 'existential', which are the only two types we handle.")`;
  msg terminate="yes" `$message`;
}

tpl [quantifier[@type = "existential"]] {
  "ex "; ilist(#separ=",", #elems=`variable`); " st ";  apply[*[position() = last()]]; "";
}

tpl [quantifier[@type = "universal"]] {
  "for "; ilist(#separ=",", #elems=`variable`); " holds ";  apply[*[position() = last()]]; "";
}

tpl [negation|] { " not "; apply; " "; }
tpl [function|predicate] {
    if [name(..)="quantifier"] { "("; }
    $tc = { transl_constr(#nm=`@name`); }
    if [contains($tc, ":attr") or contains($tc, ":mode")  or contains($tc, ":struct")] {
       " is "; apply[*[1]]; " "; $tc;
       "("; ilist(#separ=",", #elems=`*[position()>1]`); ")"; ")";
    }
    else { $tc; if[count(*)>0] {"("; ilist(#separ=",", #elems=`*`); ")"; }}
    if [name(..)="quantifier"] { ")"; }
}
tpl [conjunction] { " "; ilist(#separ=" & ", #elems=`*`); " "; }
tpl [disjunction] { " "; ilist(#separ=" or ", #elems=`*`); " "; }
tpl [implication] { " "; apply[*[1]]; " implies "; ""; apply[*[2]]; " "; }
tpl [equivalence] {  " "; apply[*[1]]; " iff "; ""; apply[*[2]]; " "; }
tpl [defined-predicate[@name='equal']]  {
    if [name(..)="quantifier"] { "("; }
     " "; apply[*[1]]; " = "; ""; apply[*[2]]; " ";
    if [name(..)="quantifier"] { ")"; }
 }
tpl [defined-predicate[@name='false']]  { " contradiction "; }
tpl [defined-predicate[@name='true']]  { " not contradiction "; }

tpl [non-logical-data] {
    // there can be embedded inferences
    if [@name='inference'] {
       for-each [*[1]] { `@name`; }
       "("; ilist(#separ=",", #elems=`*[3]/*[not(@name='theory')]`); ")";
    }
    else { "<a href=\"#"; `@name`; "\">"; `@name`; "</a>"; } }

tpl transl_constr(#nm) { $nm; }

tpl transl_constr_old(#nm) {
    $pref = `substring-before($nm,"_")`;
    if [$pref] {
       $k = `substring($pref,1,1)`;
       $nr = `substring($pref,2)`;
       $art = `substring-after($nm,"_")`;
       // test if $nr is digit
       if [$nr >= 0] {
	  if [$k="c"]
	  {
	  $lev = `substring-before($art,"__")`;
	  "$"; $pref; " "; usto0(#s=$lev);
	  }
	  else { uc(#s=$art); ":"; mkind(#kind=$k); " "; $nr; }
	  }
       else {
       // test for skolem - esk3_4, epred1_2
	  $esk = `substring($pref,1,3)`;
	  if [$esk="esk" or $esk="epr"] { "$"; $pref; " "; $art;}
	  else { $nm; }
       }
    }
    else { $nm; }
}

tpl ilist(#separ,#elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

tpl notlist(#separ,#elems) {
 for-each [$elems] {
  "$not("; apply[.]; ")"; if [not(position()=last())] { $separ; } }
}

tpl mkind(#kind) {
   choose {
      when [$kind = 'm'] { "mode";}
      when [$kind = 'v'] { "attr";}
      when [$kind = 'r'] { "pred";}
      when [$kind = 'k'] { "func";}
      when [$kind = 'g'] { "aggr";}
      when [$kind = 'l'] { "struct";}
      when [$kind = 'u'] { "sel";}
 }}
