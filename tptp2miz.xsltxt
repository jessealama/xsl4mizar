stylesheet "1.0";

output method=text;
strip-space "*";

tpl [/] {
  choose {
    when [not(tstp)] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it lacks a 'tstp' root element.";
    }
    when [tstp[2]] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it has multiple 'tstp' root elements.";
    }
    otherwise {
      apply [tstp];
    }
  }
}

tpl [tstp] {

  // give the type 'set' to all variables appearing in the problem
  for-each [descendant::variable[@name
                                 and not(@name = preceding::variable[@name]/@name)]] {
    apply [.] mode="set";
  }

  apply;
}

tpl [comment] {
  // don't know how to properly deal with this yet

  // ":: "; `text()`;
}

tpl [formula[not(@name)]] {
  msg terminate="yes" "We encountered a formula element that lacks a name attribute.";
}

tpl [formula[@name]] {
    `@name`; ": ";
    apply[*[1]]; ";\n";
}

tpl [variable[not(@name)]] {
  msg terminate="yes" "Error: unable to render a variable element that lacks a name attribute.";
}

tpl [variable[@name]] {
  `@name`;
}

tpl [variable[not(@name)]] mode="set" {
  msg terminate="yes" "Error: unable to assign the type 'set' to a variable that lacks a name";
}

tpl [variable[@name]] mode="set" {
  "reserve "; `@name`; " for set;\n";
}

tpl [quantifier[not(@type)]] {
  msg terminate="yes" "Error: we encountered a quantifier element that lacks a type attribute.";
}

tpl [quantifier[@type and not(@type = "universal" or @type = "existential")]] {
  $type = `@type`;
  $message = `concat ("Error: we encountered a quantifier element whose type, '", $type, "' is neither 'universal' nor 'existential', which are the only two types we handle.")`;
  msg terminate="yes" `$message`;
}

tpl [quantifier[@type = "existential"]] {
  "ex "; ilist(#separ=",", #elems=`variable`); " st ";  apply[*[position() = last()]]; "";
}

tpl [quantifier[@type = "universal"]] {
  "for "; ilist(#separ=",", #elems=`variable`); " holds ";  apply[*[position() = last()]]; "";
}

tpl [negation|] { " not "; apply; " "; }
tpl [function|predicate] {
    if [name(..)="quantifier"] { "("; }
    $tc = { transl_constr(#nm=`@name`); }
    if [contains($tc, ":attr") or contains($tc, ":mode")  or contains($tc, ":struct")] {
       " is "; apply[*[1]]; " "; $tc;
       "("; ilist(#separ=",", #elems=`*[position()>1]`); ")"; ")";
    }
    else { $tc; if[count(*)>0] {"("; ilist(#separ=",", #elems=`*`); ")"; }}
    if [name(..)="quantifier"] { ")"; }
}
tpl [conjunction] { " "; ilist(#separ=" & ", #elems=`*`); " "; }
tpl [disjunction] { " "; ilist(#separ=" or ", #elems=`*`); " "; }
tpl [implication] { " "; apply[*[1]]; " implies "; ""; apply[*[2]]; " "; }
tpl [equivalence] {  " "; apply[*[1]]; " iff "; ""; apply[*[2]]; " "; }


// the name 'equal' as a defined-predicate: from an older version of tptp?
tpl [defined-predicate[@name='equal']] {
    if [parent::quantifier] { "("; }
     " "; apply[*[1]]; " = "; ""; apply[*[2]]; " ";
    if [parent::quantifier] { ")"; }
}

tpl [predicate[@name = "="]] {
    if [parent::quantifier] { "("; }
    apply[*[1]]; " = "; ""; apply[*[2]];
    if [parent::quantifier] { ")"; }
}

tpl [defined-predicate[@name='false']]  { " contradiction "; }
tpl [defined-predicate[@name='true']]  { " not contradiction "; }

tpl [non-logical-data] {
    // there can be embedded inferences
    if [@name='inference'] {
       for-each [*[1]] { `@name`; }
       "("; ilist(#separ=",", #elems=`*[3]/*[not(@name='theory')]`); ")";
    }
    else { "<a href=\"#"; `@name`; "\">"; `@name`; "</a>"; } }

tpl transl_constr(#nm) { $nm; }

tpl ilist(#separ,#elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}

tpl notlist(#separ,#elems) {
 for-each [$elems] {
  "$not("; apply[.]; ")"; if [not(position()=last())] { $separ; } }
}

tpl mkind(#kind) {
   choose {
      when [$kind = 'm'] { "mode";}
      when [$kind = 'v'] { "attr";}
      when [$kind = 'r'] { "pred";}
      when [$kind = 'k'] { "func";}
      when [$kind = 'g'] { "aggr";}
      when [$kind = 'l'] { "struct";}
      when [$kind = 'u'] { "sel";}
 }}
