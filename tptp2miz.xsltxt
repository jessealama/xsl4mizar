stylesheet "1.0";

output method=text;
strip-space "*";

tpl [/] {
  choose {
    when [not(tstp)] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it lacks a 'tstp' root element.";
    }
    when [tstp[2]] {
      msg terminate="yes" "Error: this does not appear to be a TSTP XML document, because it has multiple 'tstp' root elements.";
    }
    otherwise {
      apply [tstp];
    }
  }
}

tpl [tstp] {

  // give the type 'set' to all variables appearing in the problem
  for-each [descendant::variable[@name
                                 and not(@name = preceding::variable[@name]/@name)]] {
    apply [.] mode="set";
  }

  apply;
}

tpl [comment] {
  // don't know how to properly deal with this yet.  We need to
  // properly handle whitespace.

  // ":: "; `text()`;
}

tpl [formula[not(@name)]] {
  msg terminate="yes" "We encountered a formula element that lacks a name attribute.";
}

tpl [formula[@name]] {
    `@name`; ": ";
    apply[*[1]]; ";\n";
}

tpl [variable[not(@name)]] {
  msg terminate="yes" "Error: unable to render a variable element that lacks a name attribute.";
}

tpl [variable[@name]] {
  `@name`;
}

tpl [variable[not(@name)]] mode="set" {
  msg terminate="yes" "Error: unable to assign the type 'set' to a variable that lacks a name";
}

tpl [variable[@name]] mode="set" {
  "reserve "; `@name`; " for set;\n";
}

tpl [quantifier[not(@type)]] {
  msg terminate="yes" "Error: we encountered a quantifier element that lacks a type attribute.";
}

tpl [quantifier[@type and not(@type = "universal" or @type = "existential")]] {
  $type = `@type`;
  $message = `concat ("Error: we encountered a quantifier element whose type, '", $type, "' is neither 'universal' nor 'existential', which are the only two types we handle.")`;
  msg terminate="yes" `$message`;
}

tpl [quantifier[@type = "existential"]] {
  "ex "; ilist(#separ=",", #elems=`variable`); " st ";  apply[*[position() = last()]]; "";
}

tpl [quantifier[@type = "universal"]] {
  "for "; ilist(#separ=",", #elems=`variable`); " holds ";  apply[*[position() = last()]]; "";
}

tpl [negation|] { "not "; apply; }

tpl [function[not(@name)]] {
  msg terminate="yes" "Error: we cannot render a function element that lacks a name.";
}

tpl [predicate[not(@name)]] {
  msg terminate="yes" "Error: we cannot render a predicate element that lacks a name.";
}

tpl [function[@name]|predicate[@name]] {
  if [parent::quantifier] { "("; }

  `@name`;

  if[count(*)>0] {
    "("; ilist(#separ=",", #elems=`*`); ")";
  }

  if [parent::quantifier] { ")"; }
}

tpl [*] (#connective) mode="binary-connective" {
  "("; apply[*[1]]; " "; `$connective`; " "; apply[*[2]]; ")";
}

tpl [*] (#connective) mode="multiple-arity-connective" {
  if [count(*) > 1] { "("; }
  ilist(#separ = `concat (" ", $connective, " ")`,
        #elems = `*`);
  if [count(*) > 1] { ")"; }
}

tpl [conjunction] { apply [.] (#connective = "&") mode="multiple-arity-connective"; }
tpl [disjunction] { apply [.] (#connective = "or") mode="multiple-arity-connective"; }
tpl [implication] { apply [.] (#connective = "implies") mode="binary-connective"; }
tpl [equivalence] { apply [.] (#connective = "iff") mode="binary-connective"; }

// the name 'equal' as a defined-predicate: from an older version of tptp?
tpl [defined-predicate[@name='equal']] {
    if [parent::quantifier] { "("; }
     " "; apply[*[1]]; " = "; ""; apply[*[2]]; " ";
    if [parent::quantifier] { ")"; }
}

tpl [predicate[@name = "="]] {
    if [parent::quantifier] { "("; }
    apply[*[1]]; " = "; ""; apply[*[2]];
    if [parent::quantifier] { ")"; }
}

tpl [defined-predicate[@name='false']]  { " contradiction "; }
tpl [defined-predicate[@name='true']]  { " not contradiction "; }

tpl [non-logical-data] {
  // no-op, for now
}

tpl ilist(#separ,#elems) {
 for-each [$elems] {
  apply[.]; if [not(position()=last())] { $separ; } }
}
